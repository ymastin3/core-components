import{vueComponents as e}from"https://resources.realitymedia.digital/vue-apps/dist/hubs.js";AFRAME.registerSystem("fader-plus",{schema:{direction:{type:"string",default:"none"},duration:{type:"number",default:200},color:{type:"color",default:"white"}},init(){const e=new THREE.Mesh(new THREE.BoxGeometry,new THREE.MeshBasicMaterial({color:this.data.color,side:THREE.BackSide,opacity:0,transparent:!0,fog:!1}));e.scale.x=e.scale.y=1,e.scale.z=.15,e.matrixNeedsUpdate=!0,e.renderOrder=1,this.el.camera.add(e),this.mesh=e},fadeOut(){return this.beginTransition("out")},fadeIn(){return this.beginTransition("in")},async beginTransition(e){if(this._resolveFinish)throw new Error("Cannot fade while a fade is happening.");return this.el.setAttribute("fader-plus",{direction:e}),new Promise((t=>{this.mesh.material.opacity===("in"==e?0:1)?t():this._resolveFinish=t}))},tick(e,t){const i=this.mesh.material;this.mesh.visible="out"===this.data.direction||0!==i.opacity,this.mesh.visible&&("in"===this.data.direction?i.opacity=Math.max(0,i.opacity-1/this.data.duration*Math.min(t,50)):"out"===this.data.direction&&(i.opacity=Math.min(1,i.opacity+1/this.data.duration*Math.min(t,50))),0!==i.opacity&&1!==i.opacity||("none"!==this.data.direction&&this._resolveFinish&&(this._resolveFinish(),this._resolveFinish=null),this.el.setAttribute("fader-plus",{direction:"none"})))}});const t=new THREE.Vector3,i=new THREE.Vector3;function a(e,t){window.APP.componentRegistry=window.APP.componentRegistry||{},window.APP.componentRegistry[t]=window.APP.componentRegistry[t]||[],window.APP.componentRegistry[t].push(e)}function o(e,t){window.APP.componentRegistry&&window.APP.componentRegistry[t]&&window.APP.componentRegistry[t].splice(window.APP.componentRegistry[t].indexOf(e),1)}function r(e,t){for(;e&&(!e.components||!e.components[t]);)e=e.parentNode;return e}AFRAME.registerComponent("proximity-events",{schema:{radius:{type:"number",default:1},fuzz:{type:"number",default:.1},Yoffset:{type:"number",default:0}},init(){this.inZone=!1,this.camera=this.el.sceneEl.camera},tick(){this.camera.getWorldPosition(t),this.el.object3D.getWorldPosition(i);const e=this.inZone;t.y-=this.data.Yoffset;var a=t.distanceTo(i),o=this.data.radius+(this.inZone?this.data.fuzz:0);this.inZone=a<o,this.inZone&&!e&&this.el.emit("proximityenter"),!this.inZone&&e&&this.el.emit("proximityleave")}});let n=function(e,t){let i=t.position;return 1e6*(Math.floor(i.x/e)+5e5)+(Math.floor(i.z/e)+5e5)},s=[];function l(e){let t=e;for(;t&&t.components&&!t.components["object-region-follower"];)t=t.parentNode;if(t&&t.components&&t.components["object-region-follower"])return t.components["object-region-follower"]}function c(e){s[e]?s[e]++:s[e]=1,console.log("Avatars in region "+e+": "+s[e]),1==s[e]?d(e,!0):console.log("already another avatar in this region, no change")}function h(e){s[e]&&s[e]--,console.log("Avatars left region "+e+": "+s[e]),0==s[e]?d(e,!1):console.log("still another avatar in this region, no change")}function d(e,t){if(!window.APP||!window.APP.componentRegistry)return null;console.log((t?"showing":"hiding")+" all objects in region "+e);const i=window.APP.componentRegistry["object-region-follower"]||[];for(let a=0;a<i.length;a++){const o=i[a];o.region==e&&(console.log((t?"showing ":" hiding")+o.el.className),o.showHide(t))}return null}AFRAME.registerComponent("avatar-region-follower",{schema:{size:{default:10}},init:function(){this.region=n(this.data.size,this.el.object3D),console.log("Avatar: region ",this.region),c(this.region),a(this,"avatar-region-follower")},remove:function(){o(this,"avatar-region-follower"),h(this.region)},tick:function(){let e=n(this.data.size,this.el.object3D);e!=this.region&&(h(this.region),c(e),this.region=e)}}),AFRAME.registerComponent("object-region-follower",{schema:{size:{default:10},dynamic:{default:!0}},init:function(){this.region=n(this.data.size,this.el.object3D),this.showHide=this.showHide.bind(this),this.el.components["media-video"]&&(this.wasPaused=this.el.components["media-video"].data.videoPaused),a(this,"object-region-follower")},remove:function(){o(this,"object-region-follower")},tick:function(){if(!this.data.dynamic)return;this.region=n(this.data.size,this.el.object3D);let e=!!s[this.region];this.el.object3D.visible!=e&&this.showHide(e)},showHide:function(e){this.el.object3D.visible=e,this.el.components["media-video"]&&(e?this.wasPaused!=this.el.components["media-video"].data.videoPaused&&this.el.components["media-video"].togglePlaying():(this.wasPaused=this.el.components["media-video"].data.videoPaused,this.wasPaused||this.el.components["media-video"].togglePlaying()))}}),AFRAME.registerComponent("region-hider",{schema:{size:{default:10}},init:function(){if(!r(this.el,"nav-mesh-helper"))return console.warn("region-hider component must be in the environment scene glb."),void(this.size=0);0==this.data.size&&(this.data.size=10,this.size=this.parseNodeName(this.data.size));let e=document.getElementsByClassName("RoomObjects");this.roomObjects=e.length>0?e[0]:null;this.el.sceneEl.querySelectorAll("[player-info]").forEach((e=>{e.setAttribute("avatar-region-follower",{size:this.size})}));var t=this.el.sceneEl.querySelectorAll(".RoomObjects > [media-loader]");t.forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})})),(t=this.el.sceneEl.querySelectorAll("[camera-tool], a-scene > [media-loader]")).forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})})),(t=this.el.sceneEl.querySelectorAll("[camera-tool]")).forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})})),this.sceneLoaded=this.sceneLoaded.bind(this),this.el.sceneEl.addEventListener("environment-scene-loaded",this.sceneLoaded)},isAncestor:function(e,t){for(;t&&t!=e;)t=t.parentNode;return t==e},sceneLoaded:function(){let e=document.getElementById("environment-scene").children[0].children[0];for(let i=0;i<e.length;i++){let a=e[i];if(this.isAncestor(a,this.el))continue;let o=a.className;if("CombinedMesh"===o||"scene-preview-camera"===o)continue;let r=a.components;if(r.waypoint||r.skybox||r["directional-light"]||r["ambient-light"]||r["hemisphere-light"])continue;let n=a.children;var t=!1;for(let e=0;e<n.length;e++)if(n[e].components.navmesh){t=!0;break}t||a.setAttribute("object-region-follower",{size:this.size,dynamic:!1})}!function(){if(!window.APP||!window.APP.componentRegistry)return null;console.log("showing/hiding all objects");const e=window.APP.componentRegistry["object-region-follower"]||[];for(let t=0;t<e.length;t++){const i=e[t];let a=!!s[i.region];i.el.object3D.visible!=a&&(console.log((a?"showing ":"hiding ")+i.el.className),i.showHide(a))}}()},update:function(){this.data.size!==this.size&&0==this.data.size&&(this.data.size=10,this.size=this.parseNodeName(this.data.size))},remove:function(){this.el.sceneEl.removeEventListener("environment-scene-loaded",this.sceneLoaded)},tick:function(e){if(0!=this.size){var t=this.el.sceneEl.querySelectorAll("[player-info]:not([avatar-region-follower])");t.forEach((e=>{e.setAttribute("avatar-region-follower",{size:this.size})})),(t=this.el.sceneEl.querySelectorAll("[camera-tool]:not([object-region-follower]), a-scene > [media-loader]:not([object-region-follower])")).forEach((e=>{e.setAttribute("object-region-follower",{size:this.size})}))}},parseNodeName:function(e){this.nodeName=this.el.parentEl.parentEl.className;const t=this.nodeName.match(/_([0-9]*)$/);if(!t||t.length<2)return console.warn("region-hider componentName not formatted correctly: ",this.nodeName),e;{let i=parseInt(t[1]);return i||e}}});let m={uniforms:"insertbefore:#include <common>\n",functions:"insertafter:#include <clipping_planes_pars_vertex>\n",preTransform:"insertafter:#include <begin_vertex>\n",postTransform:"insertafter:#include <project_vertex>\n",preNormal:"insertafter:#include <beginnormal_vertex>\n"},p={uniforms:"insertbefore:#include <common>\n",functions:"insertafter:#include <clipping_planes_pars_fragment>\n",preFragColor:"insertbefore:gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",postFragColor:"insertafter:gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",postMap:"insertafter:#include <map_fragment>\n",replaceMap:"replace:#include <map_fragment>\n"};const u=(e,t,i)=>{let a;for(let o in t)i[o]&&(a=/insert(before):(.*)|insert(after):(.*)|(replace):(.*)/.exec(t[o]),a&&(a[1]?e=e.replace(a[2],i[o]+"\n"+a[2]):a[3]?e=e.replace(a[4],a[4]+"\n"+i[o]):a[5]&&(e=e.replace(a[6],i[o]))));return e};function f(e){var t={};for(var i in e)for(var a in t[i]={},e[i]){var o=e[i][a];o&&(o.isColor||o.isMatrix3||o.isMatrix4||o.isVector2||o.isVector3||o.isVector4||o.isTexture)?t[i][a]=o.clone():Array.isArray(o)?t[i][a]=o.slice():t[i][a]=o}return t}let v,g={MeshStandardMaterial:"standard",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshDepthMaterial:"depth",standard:"standard",basic:"basic",lambert:"lambert",phong:"phong",depth:"depth"};const b=e=>{if(!v){let e={standard:THREE.MeshStandardMaterial,basic:THREE.MeshBasicMaterial,lambert:THREE.MeshLambertMaterial,phong:THREE.MeshPhongMaterial,depth:THREE.MeshDepthMaterial};v={};for(let t in e)v[t]={ShaderClass:e[t],ShaderLib:THREE.ShaderLib[t],Key:t,Count:0,ModifiedName:function(){return`ModifiedMesh${this.Key[0].toUpperCase()+this.Key.slice(1)}Material_${++this.Count}`},TypeCheck:`isMesh${t[0].toUpperCase()+t.slice(1)}Material`}}let t;if("function"==typeof e){for(let i in v)if(v[i].ShaderClass===e){t=v[i];break}}else if("string"==typeof e){t=v[g[e]||e]}if(!t)throw new Error("No Shader found to modify...");return t};let y=new class{constructor(e,t){this._vertexHooks={},this._fragmentHooks={},e&&this.defineVertexHooks(e),t&&this.defineFragmentHooks(t)}modify(e,t){let i=b(e);return{vertexShader:u(i.ShaderLib.vertexShader,this._vertexHooks,t.vertexShader||{}),fragmentShader:u(i.ShaderLib.fragmentShader,this._fragmentHooks,t.fragmentShader||{}),uniforms:Object.assign({},i.ShaderLib.uniforms,t.uniforms||{})}}extend(e,t){let i=b(e),a=u(i.ShaderLib.vertexShader,this._vertexHooks,t.vertexShader||{}),o=u(i.ShaderLib.fragmentShader,this._fragmentHooks,t.fragmentShader||{}),r=Object.assign({},i.ShaderLib.uniforms,t.uniforms||{}),n=t.className||i.ModifiedName(),s=new Function("BaseClass","uniforms","vertexShader","fragmentShader","cloneUniforms",`\n\n            let cls = class ${n} extends BaseClass {\n                constructor( params ){\n                    super(params)\n    \n                    this.uniforms = cloneUniforms( uniforms );\n    \n                    this.vertexShader = vertexShader;\n                    this.fragmentShader = fragmentShader;\n                    this.type = '${n}';\n    \n                    this.setValues( params );\n                }\n    \n                copy( source ){\n    \n                    super.copy(source );\n    \n                    this.uniforms = Object.assign( {}, source.uniforms );\n                    this.vertexShader = vertexShader;\n                    this.fragmentShader = fragmentShader;\n                    this.type = '${n}';\n    \n                    return this;\n    \n                }\n    \n            }\n            // var cls = function ${n}( params ){\n\n            //     //BaseClass.prototype.constructor.call( this, params );\n\n            //     this.uniforms = cloneUniforms( uniforms );\n\n            //     this.vertexShader = vertexShader;\n            //     this.fragmentShader = fragmentShader;\n            //     this.type = '${n}';\n\n            //     this.setValues( params );\n\n            // }\n\n            // cls.prototype = Object.create( BaseClass.prototype );\n            // cls.prototype.constructor = cls;\n            // cls.prototype.${i.TypeCheck} = true;\n\n            // cls.prototype.copy = function( source ){\n\n            //     BaseClass.prototype.copy.call( this, source );\n\n            //     this.uniforms = Object.assign( {}, source.uniforms );\n            //     this.vertexShader = vertexShader;\n            //     this.fragmentShader = fragmentShader;\n            //     this.type = '${n}';\n\n            //     return this;\n\n            // }\n\n            return cls;\n\n        `);return t.postModifyVertexShader&&(a=t.postModifyVertexShader(a)),t.postModifyFragmentShader&&(o=t.postModifyFragmentShader(o)),s(i.ShaderClass,r,a,o,f)}defineVertexHooks(e){for(let t in e)this._vertexHooks[t]=e[t]}defineFragmentHooks(e){for(let t in e)this._fragmentHooks[t]=e[t]}}(m,p);var x="\n        // above here, the texture lookup will be done, which we\n        // can disable by removing the map from the material\n        // but if we leave it, we can also choose the blend the texture\n        // with our shader created color, or use it in the shader or\n        // whatever\n        //\n        // vec4 texelColor = texture2D( map, vUv );\n        // texelColor = mapTexelToLinear( texelColor );\n        \n        vec2 uv = mod(vUv.xy, vec2(1.0,1.0)); //mod(vUv.xy * texRepeat.xy + texOffset.xy, vec2(1.0,1.0));\n\n        if (uv.x < 0.0) { uv.x = uv.x + 1.0;}\n        if (uv.y < 0.0) { uv.y = uv.y + 1.0;}\n        if (texFlipY > 0) { uv.y = 1.0 - uv.y;}\n        uv.x = clamp(uv.x, 0.0, 1.0);\n        uv.y = clamp(uv.y, 0.0, 1.0);\n        \n        vec4 shaderColor;\n        mainImage(shaderColor, uv.xy * iResolution.xy);\n        shaderColor = mapTexelToLinear( shaderColor );\n\n        diffuseColor *= shaderColor;\n",E={iTime:{value:0},iResolution:{value:new THREE.Vector3(512,512,1)},texRepeat:{value:new THREE.Vector2(1,1)},texOffset:{value:new THREE.Vector2(0,0)},texFlipY:{value:0}},w="\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec2 texRepeat;\nuniform vec2 texOffset;\nuniform int texFlipY; \n  ";const T=String.raw,R=Object.assign({},E,{iChannel0:{value:null}});var C;(new THREE.TextureLoader).load("https://ymastin3.github.io/core-components/a448e34b8136fae5.png",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,C=e}));let S={uniforms:R,vertexShader:{},fragmentShader:{uniforms:w+T`
      uniform sampler2D iChannel0;
        `,functions:T`
      // By Daedelus: https://www.shadertoy.com/user/Daedelus
      // license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
      #define TIMESCALE 0.25 
      #define TILES 8
      #define COLOR 0.7, 1.6, 2.8

      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
        vec2 uv = fragCoord.xy / iResolution.xy;
        uv.x *= iResolution.x / iResolution.y;
        
        vec4 noise = texture2D(iChannel0, floor(uv * float(TILES)) / float(TILES));
        float p = 1.0 - mod(noise.r + noise.g + noise.b + iTime * float(TIMESCALE), 1.0);
        p = min(max(p * 3.0 - 1.8, 0.1), 2.0);
        
        vec2 r = mod(uv * float(TILES), 1.0);
        r = vec2(pow(r.x - 0.5, 2.0), pow(r.y - 0.5, 2.0));
        p *= 1.0 - pow(min(1.0, 12.0 * dot(r, r)), 2.0);
        
        fragColor = vec4(COLOR, 1.0) * p;
      }
      `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=C},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e,t.uniforms.iChannel0.value=C}};const D=String.raw;let M={uniforms:Object.assign({},E),vertexShader:{},fragmentShader:{uniforms:w,functions:D`
        #define nPI 3.1415926535897932

        mat2 n_rotate2d(float angle){
                return mat2(cos(angle),-sin(angle),
                            sin(angle), cos(angle));
        }
        
        float n_stripe(float number) {
                float mod = mod(number, 2.0);
                //return step(0.5, mod)*step(1.5, mod);
                //return mod-1.0;
                return min(1.0, (smoothstep(0.0, 0.5, mod) - smoothstep(0.5, 1.0, mod))*1.0);
        }
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 u_resolution = iResolution.xy;
                float u_time = iTime;
                vec3 color;
                vec2 st = fragCoord.xy;
                st += 2000.0 + 998000.0*step(1.75, 1.0-sin(u_time/8.0));
                st += u_time/2000.0;
                float m = (1.0+9.0*step(1.0, 1.0-sin(u_time/8.0)))/(1.0+9.0*step(1.0, 1.0-sin(u_time/16.0)));
                vec2 st1 = st * (400.0 + 1200.0*step(1.75, 1.0+sin(u_time)) - 300.0*step(1.5, 1.0+sin(u_time/3.0)));
                st = n_rotate2d(sin(st1.x)*sin(st1.y)/(m*100.0+u_time/100.0)) * st;
                vec2 st2 = st * (100.0 + 1900.0*step(1.75, 1.0-sin(u_time/2.0)));
                st = n_rotate2d(cos(st2.x)*cos(st2.y)/(m*100.0+u_time/100.0)) * st;
                st = n_rotate2d(0.5*nPI+(nPI*0.5*step( 1.0,1.0+ sin(u_time/1.0)))
                              +(nPI*0.1*step( 1.0,1.0+ cos(u_time/2.0)))+u_time*0.0001) * st;
                st *= 10.0;
                st /= u_resolution;
                color = vec3(n_stripe(st.x*u_resolution.x/10.0+u_time/10.0));
                fragColor = vec4(color, 1.0);
        }
            `,replaceMap:x},init:function(e){let t=e;e.uniforms.texFlipY={value:t.map.flipY?0:1}},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e}};const H=String.raw;let _={uniforms:Object.assign({},E),vertexShader:{},fragmentShader:{uniforms:w,functions:H`
      //// COLORS ////

      const vec3 ORANGE = vec3(1.0, 0.6, 0.2);
      const vec3 PINK   = vec3(0.7, 0.1, 0.4); 
      const vec3 BLUE   = vec3(0.0, 0.2, 0.9); 
      const vec3 BLACK  = vec3(0.0, 0.0, 0.2);
      
      ///// NOISE /////
      
      float hash( float n ) {
          //return fract(sin(n)*43758.5453123);   
          return fract(sin(n)*75728.5453123); 
      }
      
      
      float noise( in vec2 x ) {
          vec2 p = floor(x);
          vec2 f = fract(x);
          f = f*f*(3.0-2.0*f);
          float n = p.x + p.y*57.0;
          return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);
      }
      
      ////// FBM ////// 
      
      mat2 m = mat2( 0.6, 0.6, -0.6, 0.8);
      float fbm(vec2 p){
       
          float f = 0.0;
          f += 0.5000 * noise(p); p *= m * 2.02;
          f += 0.2500 * noise(p); p *= m * 2.03;
          f += 0.1250 * noise(p); p *= m * 2.01;
          f += 0.0625 * noise(p); p *= m * 2.04;
          f /= 0.9375;
          return f;
      }
      
      
      void mainImage(out vec4 fragColor, in vec2 fragCoord){
          
          // pixel ratio
          
          vec2 uv = fragCoord.xy / iResolution.xy ;  
          vec2 p = - 1. + 2. * uv;
          p.x *= iResolution.x / iResolution.y;
           
          // domains
          
          float r = sqrt(dot(p,p)); 
          float a = cos(p.y * p.x);  
                 
          // distortion
          
          float f = fbm( 5.0 * p);
          a += fbm(vec2(1.9 - p.x, 0.9 * iTime + p.y));
          a += fbm(0.4 * p);
          r += fbm(2.9 * p);
             
          // colorize
          
          vec3 col = BLUE;
          
          float ff = 1.0 - smoothstep(-0.4, 1.1, noise(vec2(0.5 * a, 3.3 * a)) );        
          col =  mix( col, ORANGE, ff);
             
          ff = 1.0 - smoothstep(.0, 2.8, r );
          col +=  mix( col, BLACK,  ff);
          
          ff -= 1.0 - smoothstep(0.3, 0.5, fbm(vec2(1.0, 40.0 * a)) ); 
          col =  mix( col, PINK,  ff);  
            
          ff = 1.0 - smoothstep(2., 2.9, a * 1.5 ); 
          col =  mix( col, BLACK,  ff);  
                                                 
          fragColor = vec4(col, 1.);
      }
      `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:new THREE.Vector2(t.map.offset.x+Math.random(),t.map.offset.x+Math.random())},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.userData.timeOffset=10*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset}};var A="https://ymastin3.github.io/core-components/cecefb50e408d105.png";const P=String.raw,N=Object.assign({},E,{iChannel0:{value:null}});var L;(new THREE.TextureLoader).load(A,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,L=e}));let z={uniforms:N,vertexShader:{},fragmentShader:{uniforms:w+P`
      uniform sampler2D iChannel0;
        `,functions:P`
        //CBS
        //Parallax scrolling fractal galaxy.
        //Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr
        
        // http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/
        float field(in vec3 p,float s) {
            float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));
            float accum = s/4.;
            float prev = 0.;
            float tw = 0.;
            for (int i = 0; i < 26; ++i) {
                float mag = dot(p, p);
                p = abs(p) / mag + vec3(-.5, -.4, -1.5);
                float w = exp(-float(i) / 7.);
                accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
                tw += w;
                prev = mag;
            }
            return max(0., 5. * accum / tw - .7);
        }
        
        // Less iterations for second layer
        float field2(in vec3 p, float s) {
            float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));
            float accum = s/4.;
            float prev = 0.;
            float tw = 0.;
            for (int i = 0; i < 18; ++i) {
                float mag = dot(p, p);
                p = abs(p) / mag + vec3(-.5, -.4, -1.5);
                float w = exp(-float(i) / 7.);
                accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
                tw += w;
                prev = mag;
            }
            return max(0., 5. * accum / tw - .7);
        }
        
        vec3 nrand3( vec2 co )
        {
            vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );
            vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );
            vec3 c = mix(a, b, 0.5);
            return c;
        }
        
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
            vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;
            vec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);
            vec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);
            p += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));
            
            float freqs[4];
            //Sound
            freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;
            freqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;
            freqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;
            freqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;
        
            float t = field(p,freqs[2]);
            float v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));
            
            //Second Layer
            vec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);
            p2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));
            float t2 = field2(p2,freqs[3]);
            vec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);
            
            
            //Let's add some stars
            //Thanks to http://glsl.heroku.com/e#6904.0
            vec2 seed = p.xy * 2.0;	
            seed = floor(seed * iResolution.x);
            vec3 rnd = nrand3( seed );
            vec4 starcolor = vec4(pow(rnd.y,40.0));
            
            //Second Layer
            vec2 seed2 = p2.xy * 2.0;
            seed2 = floor(seed2 * iResolution.x);
            vec3 rnd2 = nrand3( seed2 );
            starcolor += vec4(pow(rnd2.y,40.0));
            
            fragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;
        }
       `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=L,e.userData.timeOffset=1e5*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=L}};const k=String.raw,j=Object.assign({},E,{iChannel0:{value:null}});var F;(new THREE.TextureLoader).load(A,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,F=e}));let O={uniforms:j,vertexShader:{},fragmentShader:{uniforms:w+k`
      uniform sampler2D iChannel0;
        `,functions:k`
        // Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)
        // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
        // Tuned via XShade (http://www.funparadigm.com/xshade/)
        
        vec2 lt_mo = vec2(0);
        
        float lt_pn( in vec3 x ) // iq noise
        {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f*f*(3.0-2.0*f);
            vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
            vec2 rg = texture(iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;
            return -1.0+2.4*mix( rg.x, rg.y, f.z );
        }
        
        vec2 lt_path(float t)
        {
            return vec2(cos(t*0.2), sin(t*0.2)) * 2.;
        }
        
        const mat3 lt_mx = mat3(1,0,0,0,7,0,0,0,7);
        const mat3 lt_my = mat3(7,0,0,0,1,0,0,0,7);
        const mat3 lt_mz = mat3(7,0,0,0,7,0,0,0,1);
        
        // base on shane tech in shader : One Tweet Cellular Pattern
        float lt_func(vec3 p)
        {
            p = fract(p/68.6) - .5;
            return min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.1;
        }
        
        vec3 lt_effect(vec3 p)
        {
            p *= lt_mz * lt_mx * lt_my * sin(p.zxy); // sin(p.zxy) is based on iq tech from shader (Sculpture III)
            return vec3(min(min(lt_func(p*lt_mx), lt_func(p*lt_my)), lt_func(p*lt_mz))/.6);
        }
        //
        
        vec4 lt_displacement(vec3 p)
        {
            vec3 col = 1.-lt_effect(p*0.8);
               col = clamp(col, -.5, 1.);
            float dist = dot(col,vec3(0.023));
            col = step(col, vec3(0.82));// black line on shape
            return vec4(dist,col);
        }
        
        vec4 lt_map(vec3 p)
        {
            p.xy -= lt_path(p.z);
            vec4 disp = lt_displacement(sin(p.zxy*2.)*0.8);
            p += sin(p.zxy*.5)*1.5;
            float l = length(p.xy) - 4.;
            return vec4(max(-l + 0.09, l) - disp.x, disp.yzw);
        }
        
        vec3 lt_nor( in vec3 pos, float prec )
        {
            vec3 eps = vec3( prec, 0., 0. );
            vec3 lt_nor = vec3(
                lt_map(pos+eps.xyy).x - lt_map(pos-eps.xyy).x,
                lt_map(pos+eps.yxy).x - lt_map(pos-eps.yxy).x,
                lt_map(pos+eps.yyx).x - lt_map(pos-eps.yyx).x );
            return normalize(lt_nor);
        }
        
        
        vec4 lt_light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)
        {
            vec3 p = ro + rd * d;
            
            // original normale
            vec3 n = lt_nor(p, 0.1);
            
            vec3 lightdir = lightpos - p;
            float lightlen = length(lightpos - p);
            lightdir /= lightlen;
            
            float amb = 0.6;
            float diff = clamp( dot( n, lightdir ), 0.0, 1.0 );
                
            vec3 brdf = vec3(0);
            brdf += amb * vec3(0.2,0.5,0.3); // color mat
            brdf += diff * 0.6;
            
            brdf = mix(brdf, lt_map(p).yzw, 0.5);// merge light and black line pattern
                
            return vec4(brdf, lightlen);
        }
        
        vec3 lt_stars(vec2 uv, vec3 rd, float d, vec2 s, vec2 g)
        {
            uv *= 800. * s.x/s.y;
            float k = fract( cos(uv.y * 0.0001 + uv.x) * 90000.);
            float var = sin(lt_pn(d*0.6+rd*182.14))*0.5+0.5;// thank to klems for the variation in my shader subluminic
            vec3 col = vec3(mix(0., 1., var*pow(k, 200.)));// come from CBS Shader "Simplicity" : https://www.shadertoy.com/view/MslGWN
            return col;
        }
        
        ////////MAIN///////////////////////////////
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 s = iResolution.xy;
            vec2 g = fragCoord;
            
           
            float time = iTime*1.0;
            float cam_a = time; // angle z
            
            float cam_e = 3.2; // elevation
            float cam_d = 4.; // distance to origin axis
            
            float maxd = 40.; // ray marching distance max
            
            vec2 uv = (g*2.-s)/s.y;
            
            vec3 col = vec3(0.);
        
            vec3 ro = vec3(lt_path(time)+lt_mo,time);
              vec3 cv = vec3(lt_path(time+0.1)+lt_mo,time+0.1);
            
            vec3 cu=vec3(0,1,0);
              vec3 rov = normalize(cv-ro);
            vec3 u = normalize(cross(cu,rov));
              vec3 v = cross(rov,u);
              vec3 rd = normalize(rov + uv.x*u + uv.y*v);
            
            vec3 curve0 = vec3(0);
            vec3 curve1 = vec3(0);
            vec3 curve2 = vec3(0);
            float outStep = 0.;
            
            float ao = 0.; // ao low cost :)
            
            float st = 0.;
            float d = 0.;
            for(int i=0;i<250;i++)
            {      
                if (st<0.025*log(d*d/st/1e5)||d>maxd) break;// special break condition for low thickness object
                st = lt_map(ro+rd*d).x;
                d += st * 0.6; // the 0.6 is selected according to the 1e5 and the 0.025 of the break condition for good result
                ao++;
            }

            if (d < maxd)
            {
                vec4 li = lt_light(ro, rd, d, ro, vec3(0));// point light on the cam
                col = li.xyz/(li.w*0.2);// cheap light attenuation
                
                   col = mix(vec3(1.-ao/100.), col, 0.5);// low cost ao :)
                fragColor.rgb = mix( col, vec3(0), 1.0-exp( -0.003*d*d ) );
            }
            else
            {
                  fragColor.rgb = lt_stars(uv, rd, d, s, fragCoord);// stars bg
            }

            // vignette
            vec2 q = fragCoord/s;
            fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); // iq vignette
                
        }
       `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=F,e.userData.timeOffset=10*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=F}};const I=String.raw,V=Object.assign({},E,{iChannel0:{value:null},iChannelResolution:{value:[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)]}});var U;(new THREE.TextureLoader).load("https://ymastin3.github.io/core-components/f27e0104605f0cd7.png",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,U=e,console.log("noise texture size: ",e.image.width,e.image.height)}));let W={uniforms:V,vertexShader:{},fragmentShader:{uniforms:w+I`
      uniform sampler2D iChannel0;
      uniform vec3 iChannelResolution[4];
        `,functions:I`
        // Created by inigo quilez - iq/2013
// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. 
// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.
// You can share a link to it or an unmodified screenshot of it provided you attribute "by Inigo Quilez, @iquilezles and iquilezles.org". 
// If you are a techer, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.

float fire_noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);
	f = f*f*(3.0-2.0*f);
	
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
	vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;
	return mix( rg.x, rg.y, f.z );
}

vec4 fire_map( vec3 p )
{
	float den = 0.2 - p.y;

    // invert space	
	p = -7.0*p/dot(p,p);

    // twist space	
	float co = cos(den - 0.25*iTime);
	float si = sin(den - 0.25*iTime);
	p.xz = mat2(co,-si,si,co)*p.xz;

    // smoke	
	float f;
	vec3 q = p                          - vec3(0.0,1.0,0.0)*iTime;;
    f  = 0.50000*fire_noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.25000*fire_noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.12500*fire_noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.06250*fire_noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.03125*fire_noise( q );

	den = clamp( den + 4.0*f, 0.0, 1.0 );
	
	vec3 col = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), den ) + 0.05*sin(p);
	
	return vec4( col, den );
}

vec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )
{
	vec4 sum = vec4( 0.0 );

	float t = 0.0;

    // dithering	
	t += 0.05*textureLod( iChannel0, pixel.xy/iChannelResolution[0].x, 0.0 ).x;
	
	for( int i=0; i<100; i++ )
	{
		if( sum.a > 0.99 ) break;
		
		vec3 pos = ro + t*rd;
		vec4 col = fire_map( pos );
		
		col.xyz *= mix( 3.1*vec3(1.0,0.5,0.05), vec3(0.48,0.53,0.5), clamp( (pos.y-0.2)/2.0, 0.0, 1.0 ) );
		
		col.a *= 0.6;
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	

		t += 0.05;
	}

	return clamp( sum.xyz, 0.0, 1.0 );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 q = fragCoord.xy / iResolution.xy;
    vec2 p = -1.0 + 2.0*q;
    p.x *= iResolution.x/ iResolution.y;
	
    vec2 mo = vec2(0.5,0.5); //iMouse.xy / iResolution.xy;
    //if( iMouse.w<=0.00001 ) mo=vec2(0.0);
	
    // camera
    vec3 ro = 4.0*normalize(vec3(cos(3.0*mo.x), 1.4 - 1.0*(mo.y-.1), sin(3.0*mo.x)));
	vec3 ta = vec3(0.0, 1.0, 0.0);
	float cr = 0.5*cos(0.7*iTime);
	
    // shake		
	ro += 0.1*(-1.0+2.0*textureLod( iChannel0, iTime*vec2(0.010,0.014), 0.0 ).xyz);
	ta += 0.1*(-1.0+2.0*textureLod( iChannel0, iTime*vec2(0.013,0.008), 0.0 ).xyz);
	
	// build ray
    vec3 ww = normalize( ta - ro);
    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));
    vec3 vv = normalize(cross(ww,uu));
    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );
	
    // raymarch	
	vec3 col = raymarch( ro, rd, fragCoord );
	
	// contrast and vignetting	
	col = col*0.5 + 0.5*col*col*(3.0-2.0*col);
	col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );
	
    fragColor = vec4( col, 1.0 );
}

       `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=U,e.userData.timeOffset=1e5*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=U,t.uniforms.iChannelResolution.value[0].x=U.image.width,t.uniforms.iChannelResolution.value[0].y=U.image.height}};const B=String.raw;let q={uniforms:Object.assign({},E),vertexShader:{},fragmentShader:{uniforms:w,functions:B`

        float mrand(vec2 coords)
        {
            return fract(sin(dot(coords, vec2(56.3456,78.3456)) * 5.0) * 10000.0);
        }
        
        float mnoise(vec2 coords)
        {
            vec2 i = floor(coords);
            vec2 f = fract(coords);
        
            float a = mrand(i);
            float b = mrand(i + vec2(1.0, 0.0));
            float c = mrand(i + vec2(0.0, 1.0));
            float d = mrand(i + vec2(1.0, 1.0));
        
            vec2 cubic = f * f * (3.0 - 2.0 * f);
        
            return mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;
        }
        
        float fbm(vec2 coords)
        {
            float value = 0.0;
            float scale = 0.5;
        
            for (int i = 0; i < 10; i++)
            {
                value += mnoise(coords) * scale;
                coords *= 4.0;
                scale *= 0.5;
            }
        
            return value;
        }
        
        
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 uv = fragCoord.xy / iResolution.y * 2.0;
         
            float final = 0.0;
            
            for (int i =1; i < 6; i++)
            {
                vec2 motion = vec2(fbm(uv + vec2(0.0,iTime) * 0.05 + vec2(i, 0.0)));
        
                final += fbm(uv + motion);
        
            }
            
            final /= 5.0;
            fragColor = vec4(mix(vec3(-0.3), vec3(0.45, 0.4, 0.6) + vec3(0.6), final), 1);
        }
    `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.userData.timeOffset=10*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.0012*e+t.userData.timeOffset}};const Y=String.raw,G={animate:!1,noiseMode:"scale",invert:!1,sharpen:!0,scaleByPrev:!1,gain:.54,lacunarity:2,octaves:5,scale1:3,scale2:3,timeScaleX:.4,timeScaleY:.3,color1:[0,0,0],color2:[130,129,129],color3:[110,110,110],color4:[82,51,13],offsetAX:0,offsetAY:0,offsetBX:3.7,offsetBY:.9,offsetCX:2.1,offsetCY:3.2,offsetDX:4.3,offsetDY:2.8,offsetX:0,offsetY:0};let X={uniforms:{mb_animate:{value:G.animate},mb_color1:{value:G.color1.map((e=>e/255))},mb_color2:{value:G.color2.map((e=>e/255))},mb_color3:{value:G.color3.map((e=>e/255))},mb_color4:{value:G.color4.map((e=>e/255))},mb_gain:{value:G.gain},mb_invert:{value:G.invert},mb_lacunarity:{value:G.lacunarity},mb_noiseMode:{value:0},mb_octaves:{value:G.octaves},mb_offset:{value:[G.offsetX,G.offsetY]},mb_offsetA:{value:[G.offsetAX,G.offsetAY]},mb_offsetB:{value:[G.offsetBX,G.offsetBY]},mb_offsetC:{value:[G.offsetCX,G.offsetCY]},mb_offsetD:{value:[G.offsetDX,G.offsetDY]},mb_scale1:{value:G.scale1},mb_scale2:{value:G.scale2},mb_scaleByPrev:{value:G.scaleByPrev},mb_sharpen:{value:G.sharpen},mb_time:{value:0},mb_timeScale:{value:[G.timeScaleX,G.timeScaleY]},texRepeat:{value:new THREE.Vector2(1,1)},texOffset:{value:new THREE.Vector2(0,0)}},vertexShader:{},fragmentShader:{uniforms:Y`
            uniform bool mb_animate;
            uniform vec3 mb_color1;
            uniform vec3 mb_color2;
            uniform vec3 mb_color3;
            uniform vec3 mb_color4;
            uniform float mb_gain;
            uniform bool mb_invert;
            uniform float mb_lacunarity;
            uniform int mb_noiseMode;
            uniform int mb_octaves;
            uniform vec2 mb_offset;
            uniform vec2 mb_offsetA;
            uniform vec2 mb_offsetB;
            uniform vec2 mb_offsetC;
            uniform vec2 mb_offsetD;
            uniform float mb_scale1;
            uniform float mb_scale2;
            uniform bool mb_scaleByPrev;
            uniform bool mb_sharpen;
            uniform float mb_time;
            uniform vec2 mb_timeScale;
            uniform vec2 texRepeat;
            uniform vec2 texOffset;
                    `,functions:Y`
        // Some useful functions
        vec3 mb_mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mb_mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 mb_permute(vec3 x) { return mb_mod289(((x*34.0)+1.0)*x); }
        
        //
        // Description : GLSL 2D simplex noise function
        //      Author : Ian McEwan, Ashima Arts
        //  Maintainer : ijm
        //     Lastmod : 20110822 (ijm)
        //     License :
        //  Copyright (C) 2011 Ashima Arts. All rights reserved.
        //  Distributed under the MIT License. See LICENSE file.
        //  https://github.com/ashima/webgl-noise
        //
        float mb_snoise(vec2 v) {
            // Precompute values for skewed triangular grid
            const vec4 C = vec4(0.211324865405187,
                                // (3.0-sqrt(3.0))/6.0
                                0.366025403784439,
                                // 0.5*(sqrt(3.0)-1.0)
                                -0.577350269189626,
                                // -1.0 + 2.0 * C.x
                                0.024390243902439);
                                // 1.0 / 41.0
        
            // First corner (x0)
            vec2 i  = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
        
            // Other two corners (x1, x2)
            vec2 i1 = vec2(0.0);
            i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);
            vec2 x1 = x0.xy + C.xx - i1;
            vec2 x2 = x0.xy + C.zz;
        
            // Do some permutations to avoid
            // truncation effects in permutation
            i = mb_mod289(i);
            vec3 p = mb_permute(
                    mb_permute( i.y + vec3(0.0, i1.y, 1.0))
                        + i.x + vec3(0.0, i1.x, 1.0 ));
        
            vec3 m = max(0.5 - vec3(
                                dot(x0,x0),
                                dot(x1,x1),
                                dot(x2,x2)
                                ), 0.0);
        
            m = m*m;
            m = m*m;
        
            // Gradients:
            //  41 pts uniformly over a line, mapped onto a diamond
            //  The ring size 17*17 = 289 is close to a multiple
            //      of 41 (41*7 = 287)
        
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
        
            // Normalise gradients implicitly by scaling m
            // Approximation of: m *= inversesqrt(a0*a0 + h*h);
            m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);
        
            // Compute final noise value at P
            vec3 g = vec3(0.0);
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);
            return 130.0 * dot(m, g);
        }
        
        float mb_getNoiseVal(vec2 p) {
            float raw = mb_snoise(p);
        
            if (mb_noiseMode == 1) {
                return abs(raw);
            }
        
            return raw * 0.5 + 0.5;
        }
        
        float mb_fbm(vec2 p) {
            float sum = 0.0;
            float freq = 1.0;
            float amp = 0.5;
            float prev = 1.0;
        
            for (int i = 0; i < mb_octaves; i++) {
                float n = mb_getNoiseVal(p * freq);
        
                if (mb_invert) {
                    n = 1.0 - n;
                }
        
                if (mb_sharpen) {
                    n = n * n;
                }
        
                sum += n * amp;
        
                if (mb_scaleByPrev) {
                    sum += n * amp * prev;
                }
        
                prev = n;
                freq *= mb_lacunarity;
                amp *= mb_gain;
            }
        
            return sum;
        }
        
        float mb_pattern(in vec2 p, out vec2 q, out vec2 r) {
            p *= mb_scale1;
            p += mb_offset;
        
            float t = 0.0;
            if (mb_animate) {
                t = mb_time * 0.1;
            }
        
            q = vec2(mb_fbm(p + mb_offsetA + t * mb_timeScale.x), mb_fbm(p + mb_offsetB - t * mb_timeScale.y));
            r = vec2(mb_fbm(p + mb_scale2 * q + mb_offsetC), mb_fbm(p + mb_scale2 * q + mb_offsetD));
        
            return mb_fbm(p + mb_scale2 * r);
        }
    `,replaceMap:Y`
        vec3 marbleColor = vec3(0.0);

        vec2 q;
        vec2 r;

        vec2 uv = mod(vUv.xy, vec2(1.0,1.0)); 
        if (uv.x < 0.0) { uv.x = uv.x + 1.0;}
        if (uv.y < 0.0) { uv.y = uv.y + 1.0;}
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);

        float f = mb_pattern(uv, q, r);
        
        marbleColor = mix(mb_color1, mb_color2, f);
        marbleColor = mix(marbleColor, mb_color3, length(q) / 2.0);
        marbleColor = mix(marbleColor, mb_color4, r.y / 2.0);

        vec4 marbleColor4 = mapTexelToLinear( vec4(marbleColor,1.0) );

        diffuseColor *= marbleColor4;
    `},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.mb_invert={value:t.map.flipY?G.invert:!G.invert},e.uniforms.mb_offsetA={value:new THREE.Vector2(G.offsetAX+Math.random(),G.offsetAY+Math.random())},e.uniforms.mb_offsetB={value:new THREE.Vector2(G.offsetBX+Math.random(),G.offsetBY+Math.random())}},updateUniforms:function(e,t){t.uniforms.mb_time.value=.001*e}};const $=String.raw,Z=Object.assign({},E,{iChannel0:{value:null},iChannel1:{value:null}}),Q=new THREE.TextureLoader;var J,K;Q.load(A,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,J=e})),Q.load("https://ymastin3.github.io/core-components/1ec965c5d6df577c.jpg",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,K=e}));let ee={uniforms:Z,vertexShader:{},fragmentShader:{uniforms:w+$`
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        `,functions:$`
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 uv = fragCoord.xy / iResolution.xy;
            vec2 warpUV = 2. * uv;
        
            float d = length( warpUV );
            vec2 st = warpUV*0.1 + 0.2*vec2(cos(0.071*iTime*2.+d),
                                        sin(0.073*iTime*2.-d));
        
            vec3 warpedCol = texture( iChannel0, st ).xyz * 2.0;
            float w = max( warpedCol.r, 0.85);
            
            vec2 offset = 0.01 * cos( warpedCol.rg * 3.14159 );
            vec3 col = texture( iChannel1, uv + offset ).rgb * vec3(0.8, 0.8, 1.5) ;
            col *= w*1.2;
            
            fragColor = vec4( mix(col, texture( iChannel1, uv + offset ).rgb, 0.5),  1.0);
        }
        `,replaceMap:x},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.uniforms.iChannel0.value=J,e.uniforms.iChannel1.value=K,e.userData.timeOffset=1e4*(Math.random()+.5)},updateUniforms:function(e,t){t.uniforms.iTime.value=.001*e+t.userData.timeOffset,t.uniforms.iChannel0.value=J,t.uniforms.iChannel1.value=K}};var te="https://ymastin3.github.io/core-components/481a92b44e56dad4.png";const ie=String.raw,ae={warpTime:{value:0},warpTex:{value:null},texRepeat:{value:new THREE.Vector2(1,1)},texOffset:{value:new THREE.Vector2(0,0)},texFlipY:{value:0}};var oe;(new THREE.TextureLoader).load(te,(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,oe=e}));let re={uniforms:ae,vertexShader:{},fragmentShader:{uniforms:ie`
        uniform float warpTime;
        uniform sampler2D warpTex;
        uniform vec2 texRepeat;
        uniform vec2 texOffset;
        uniform int texFlipY; 
                `,replaceMap:ie`
          float t = warpTime;

          vec2 uv = mod(vUv.xy, vec2(1.0,1.0)); //mod(vUv.xy * texRepeat.xy + texOffset.xy, vec2(1.0,1.0));

          if (uv.x < 0.0) { uv.x = uv.x + 1.0;}
          if (uv.y < 0.0) { uv.y = uv.y + 1.0;}
          if (texFlipY > 0) { uv.y = 1.0 - uv.y;}
          uv.x = clamp(uv.x, 0.0, 1.0);
          uv.y = clamp(uv.y, 0.0, 1.0);
  
          vec2 scaledUV = uv * 2.0 - 1.0;
          vec2 puv = vec2(length(scaledUV.xy), atan(scaledUV.x, scaledUV.y));
          vec4 col = texture2D(warpTex, vec2(log(puv.x) + t / 5.0, puv.y / 3.1415926 ));
          float glow = (1.0 - puv.x) * (0.5 + (sin(t) + 2.0 ) / 4.0);
          // blue glow
          col += vec4(118.0/255.0, 144.0/255.0, 219.0/255.0, 1.0) * (0.4 + glow * 1.0);
          // white glow
          col += vec4(0.2) * smoothstep(0.0, 2.0, glow * glow);
          
          col = mapTexelToLinear( col );
          diffuseColor *= col;
        `},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map.repeat},e.uniforms.texOffset={value:t.map.offset},e.uniforms.texFlipY={value:t.map.flipY?0:1},e.userData.timeOffset=10*(Math.random()+.5),e.uniforms.warpTex.value=oe,e.uniforms.warpTime={value:0}},updateUniforms:function(e,t){t.uniforms.warpTime.value=.001*e+t.userData.timeOffset,t.uniforms.warpTex.value=oe}};const ne=String.raw,se={warpTime:{value:0},warpTex:{value:null},texRepeat:{value:new THREE.Vector2(1,1)},texOffset:{value:new THREE.Vector2(0,0)},texFlipY:{value:0},portalCubeMap:{value:new THREE.CubeTexture},portalTime:{value:0},portalRadius:{value:.5},portalRingColor:{value:new THREE.Color("red")},invertWarpColor:{value:0},texInvSize:{value:new THREE.Vector2(1,1)}};let le=new THREE.CubeTexture;var ce;(new THREE.TextureLoader).load(te,(e=>{e.minFilter=THREE.NearestMipmapNearestFilter,e.magFilter=THREE.NearestMipmapNearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,ce=e,le.images=[e.image,e.image,e.image,e.image,e.image,e.image],le.needsUpdate=!0}));let he={uniforms:se,vertexShader:{uniforms:ne`
        varying vec3 vRay;
        varying vec3 portalNormal;
        //varying vec3 cameraLocal;
        `,postTransform:ne`
        // vec3 cameraLocal = (inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;
        vec3 cameraLocal = (inverse(modelViewMatrix) * vec4(0.0,0.0,0.0, 1.0)).xyz;
        vRay = position - cameraLocal;
        if (vRay.z < 0.0) {
            vRay.z = -vRay.z;
            vRay.x = -vRay.x;
        }
        //vRay = vec3(mvPosition.x, mvPosition.y, mvPosition.z);
        portalNormal = normalize(-1. * vRay);
        //float portal_dist = length(cameraLocal);
        float portal_dist = length(vRay);
        vRay.z *= 1.1 / (1. + pow(portal_dist, 0.5)); // Change FOV by squashing local Z direction
      `},fragmentShader:{functions:"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }  \n",uniforms:ne`
        uniform samplerCube portalCubeMap;
        uniform float portalRadius;
        uniform vec3 portalRingColor;
        uniform float portalTime;
        uniform int invertWarpColor;

        uniform vec2 texInvSize;

        varying vec3 vRay;
        varying vec3 portalNormal;
       // varying vec3 cameraLocal;

        uniform float warpTime;
        uniform sampler2D warpTex;
        uniform vec2 texRepeat;
        uniform vec2 texOffset;
        uniform int texFlipY; 

        #define RING_WIDTH 0.1
        #define RING_HARD_OUTER 0.01
        #define RING_HARD_INNER 0.08
        `,replaceMap:ne`
          float t = warpTime;

          vec2 uv = mod(vUv.xy, vec2(1.0,1.0)); //mod(vUv.xy * texRepeat.xy + texOffset.xy, vec2(1.0,1.0));

          if (uv.x < 0.0) { uv.x = uv.x + 1.0;}
          if (uv.y < 0.0) { uv.y = uv.y + 1.0;}
          if (texFlipY > 0) { uv.y = 1.0 - uv.y;}
          uv.x = clamp(uv.x, 0.0, 1.0);
          uv.y = clamp(uv.y, 0.0, 1.0);
  
          vec2 scaledUV = uv * 2.0 - 1.0;
          vec2 puv = vec2(length(scaledUV.xy), atan(scaledUV.x, scaledUV.y));
          vec4 col = texture2D(warpTex, vec2(log(puv.x) + t / 5.0, puv.y / 3.1415926 ));

          float glow = (1.0 - puv.x) * (0.5 + (sin(t) + 2.0 ) / 4.0);
          // blue glow
          col += vec4(118.0/255.0, 144.0/255.0, 219.0/255.0, 1.0) * (0.4 + glow * 1.0);
          // white glow
          col += vec4(0.2) * smoothstep(0.0, 2.0, glow * glow);
          col = mapTexelToLinear( col );
         
          if (invertWarpColor > 0) {
              col = vec4(col.b, col.g, col.r, col.a);
          }

          /// portal shader effect
          vec2 portal_coord = vUv * 2.0 - 1.0;
          float portal_noise = snoise(vec3(portal_coord * 1., portalTime)) * 0.5 + 0.5;
        
          // Polar distance
          float portal_dist = length(portal_coord);
          portal_dist += portal_noise * 0.2;
        
          float maskOuter = 1.0 - smoothstep(portalRadius - RING_HARD_OUTER, portalRadius, portal_dist);
          float maskInner = 1.0 - smoothstep(portalRadius - RING_WIDTH, portalRadius - RING_WIDTH + RING_HARD_INNER, portal_dist);
          float portal_distortion = smoothstep(portalRadius - 0.2, portalRadius + 0.2, portal_dist);
          
          vec3 portalnormal = normalize(portalNormal);
          vec3 forwardPortal = vec3(0.0, 0.0, -1.0);

          float portal_directView = smoothstep(0.0, 0.8, dot(portalnormal, forwardPortal));
          vec3 portal_tangentOutward = normalize(vec3(portal_coord, 0.0));
          vec3 portal_ray = mix(vRay, portal_tangentOutward, portal_distortion);

          vec4 myCubeTexel = textureCube(portalCubeMap, portal_ray);

        //   myCubeTexel += textureCube(portalCubeMap, normalize(vec3(portal_ray.x - texInvSize.s, portal_ray.yz))) / 8.0;        
        //   myCubeTexel += textureCube(portalCubeMap, normalize(vec3(portal_ray.x - texInvSize.s, portal_ray.yz))) / 8.0;        
        //   myCubeTexel += textureCube(portalCubeMap, normalize(vec3(portal_ray.x, portal_ray.y - texInvSize.t, portal_ray.z))) / 8.0;        
        //   myCubeTexel += textureCube(portalCubeMap, normalize(vec3(portal_ray.x, portal_ray.y - texInvSize.t, portal_ray.z))) / 8.0;        

          myCubeTexel = mapTexelToLinear( myCubeTexel );

        //   vec4 posCol = vec4(smoothstep(-6.0, 6.0, cameraLocal), 1.0); //normalize((cameraLocal / 6.0));
        //   myCubeTexel = posCol; // vec4(posCol.x, posCol.y, posCol.y, 1.0);
          vec3 centerLayer = myCubeTexel.rgb * maskInner;
          vec3 ringLayer = portalRingColor * (1. - maskInner);
          vec3 portal_composite = centerLayer + ringLayer;
        
          //gl_FragColor 
          vec4 portalCol = vec4(portal_composite, (maskOuter - maskInner) + maskInner * portal_directView);
        
          // blend the two
          portalCol.rgb *= portalCol.a; //premultiply source 
          col.rgb *= (1.0 - portalCol.a);
          col.rgb += portalCol.rgb;

          diffuseColor *= col;
        `},init:function(e){let t=e;e.uniforms.texRepeat={value:t.map&&t.map.repeat?t.map.repeat:new THREE.Vector2(1,1)},e.uniforms.texOffset={value:t.map&&t.map.offset?t.map.offset:new THREE.Vector2(0,0)},e.uniforms.texFlipY={value:t.map&&t.map.flipY?0:1},e.userData.timeOffset=10*(Math.random()+.5),e.uniforms.warpTex.value=ce,e.uniforms.warpTime={value:0},e.uniforms.portalTime={value:0},e.uniforms.invertWarpColor={value:!!t.userData.invertWarpColor&&t.userData.invertWarpColor},e.uniforms.portalRingColor={value:t.userData.ringColor?t.userData.ringColor:new THREE.Color("red")},e.uniforms.portalCubeMap={value:t.userData.cubeMap?t.userData.cubeMap:le},e.uniforms.portalRadius={value:t.userData.radius?t.userData.radius:.5}},updateUniforms:function(e,t){if(t.uniforms.warpTime.value=.001*e+t.userData.timeOffset,t.uniforms.portalTime.value=.001*e+t.userData.timeOffset,t.uniforms.warpTex.value=ce,t.uniforms.portalCubeMap.value=t.userData.cubeMap?t.userData.cubeMap:le,t.uniforms.portalRadius.value=t.userData.radius?t.userData.radius:.5,t.userData.cubeMap&&Array.isArray(t.userData.cubeMap.images)&&t.userData.cubeMap.images[0]){let e=t.userData.cubeMap.images[0].height,i=t.userData.cubeMap.images[0].width;t.uniforms.texInvSize.value=new THREE.Vector2(i,e)}}};function de(e,t,i,a={}){var o=t.object3DMap.mesh;o||(o=t.object3D);let r=[],n=t=>{let o=t;o.material&&function(e,t){let i=e;if(i.material)Array.isArray(i.material)?i.material.map(t):t(i.material)}(o,(t=>{if(!i||t.name===i){let i=function(e,t,i){var a;try{a=y.extend(e.type,{uniforms:t.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})}catch(e){return null}let o=new a;switch(e.type){case"MeshStandardMaterial":THREE.MeshStandardMaterial.prototype.copy.call(o,e);break;case"MeshPhongMaterial":THREE.MeshPhongMaterial.prototype.copy.call(o,e);break;case"MeshBasicMaterial":THREE.MeshBasicMaterial.prototype.copy.call(o,e)}return o.userData=i,o.needsUpdate=!0,t.init(o),o}(t,e,a);i&&(o.material=i,r.push(i))}}));const s=t.children;for(let e=0;e<s.length;e++)n(s[e])};return n(o),r}new THREE.Vector3,new THREE.Vector3(0,0,1);const me={once:!0};AFRAME.registerComponent("shader",{materials:null,shaderDef:null,schema:{name:{type:"string",default:"noise"},target:{type:"string",default:""}},init:function(){var e;switch(this.data.name){case"noise":e=M;break;case"warp":e=re;break;case"warp-portal":e=he;break;case"liquidmarble":e=_;break;case"bleepyblocks":e=S;break;case"galaxy":e=z;break;case"lacetunnel":e=O;break;case"firetunnel":e=W;break;case"mist":e=q;break;case"marble1":e=X;break;default:console.warn("unknown name '"+this.data.name+"' passed to shader component"),e=ee}let t=r(this.el,"gltf-model-plus"),i=()=>{let t=this.data.target;0==t.length&&(t=null),this.materials=de(e,this.el,t)};t&&t.addEventListener("model-loaded",(()=>{if(this.el.components["media-loader"]){let e=()=>{i(),this.el.removeEventListener("model-loaded",e)};this.el.addEventListener("media-loaded",e)}else i()}),me),this.shaderDef=e},tick:function(e){if(null==this.shaderDef||null==this.materials)return;let t=this.shaderDef;this.materials.map((i=>{t.updateUniforms(e,i)}))}});var pe="https://ymastin3.github.io/core-components/2aeb00b64ae9568f.jpg",ue="https://ymastin3.github.io/core-components/50a1b6d338cb246e.jpg",fe="https://ymastin3.github.io/core-components/aeab2091e4a53e9d.png",ve="https://ymastin3.github.io/core-components/0ce46c422f945a96.jpg",ge="https://ymastin3.github.io/core-components/6a3e8b4332d47ce2.jpg";window.APP.writeWayPointTextures=function(e){Array.isArray(e)||(e=[e]);for(let t=0;t<e.length;t++){let i=document.getElementsByClassName(e[t]);for(let a=0;a<i.length;a++)if(i[a].components.waypoint){let o=null;if(console.log("didn't find waypoint with cubeCamera '"+e[t]+"', creating one."),THREE.REVISION<125)o=new be(.1,1e3,1024);else{const e=new THREE.WebGLCubeRenderTarget(1024,{encoding:THREE.sRGBEncoding,generateMipmaps:!0});o=new be(1,1e5,e)}o.position.y=1.6,o.needsUpdate=!0,i[a].object3D.add(o),o.update(window.APP.scene.renderer,window.APP.scene.object3D),o.saveCubeMapSides(e[t]),i[a].object3D.remove(o);break}}};class be extends THREE.CubeCamera{constructor(...e){super(...e),this.canvas=document.createElement("canvas"),this.canvas.width=1024,this.canvas.height=1024,this.ctx=this.canvas.getContext("2d")}saveCubeMapSides(e){for(let t=0;t<6;t++)this.capture(e,t)}capture(e,t){window.APP.scene.renderer,this.renderCapture(t),this.saveCapture(e,t)}renderCapture(e){var t,i=new Uint8Array(4194304);window.APP.scene.renderer.readRenderTargetPixels(this.renderTarget,0,0,1024,1024,i,e),t=new ImageData(new Uint8ClampedArray(i),1024,1024),this.ctx.putImageData(t,0,0)}flipPixelsVertically(e,t,i){for(var a=e.slice(0),o=0;o<t;++o)for(var r=0;r<i;++r)a[3*o+r*t*3]=e[3*o+(i-r-1)*t*3],a[3*o+1+r*t*3]=e[3*o+1+(i-r-1)*t*3],a[3*o+2+r*t*3]=e[3*o+2+(i-r-1)*t*3];return a}convert3to4(e,t,i){for(var a=new Uint8Array(4194304),o=0;o<t;++o)for(var r=0;r<i;++r)a[4*o+r*t*4]=e[3*o+r*t*3],a[4*o+1+r*t*4]=e[3*o+1+r*t*3],a[4*o+2+r*t*4]=e[3*o+2+r*t*3],a[4*o+3+r*t*4]=255;return a}sides=["Right","Left","Top","Bottom","Front","Back"];saveCapture(e,t){this.canvas.toBlob((i=>{var a=e+"-"+this.sides[t]+".png",o=document.createElement("a"),r=URL.createObjectURL(i);o.href=r,o.setAttribute("download",a),o.innerHTML="downloading...",o.style.display="none",document.body.appendChild(o),setTimeout((function(){o.click(),document.body.removeChild(o)}),1)}),"image/png")}}const ye=new THREE.Vector3,xe=new THREE.Vector3,Ee=new THREE.Vector3,we=new THREE.Quaternion,Te=new THREE.Matrix4,Re=new THREE.TextureLoader,Ce=new THREE.MeshStandardMaterial({color:16777215,metalness:0,roughness:0}),Se=new THREE.MeshStandardMaterial({color:16777215,metalness:0,roughness:0});Re.load(pe,(e=>{Ce.map=e,e.repeat.set(1,25),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Ce.needsUpdate=!0})),Re.load(pe,(e=>{Se.map=e,e.repeat.set(1,1),e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,Se.needsUpdate=!0})),Re.load(ue,(e=>{Ce.bumpMap=e,e.repeat.set(1,25),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Ce.needsUpdate=!0})),Re.load(ue,(e=>{Se.bumpMap=e,e.repeat.set(1,1),e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,Se.needsUpdate=!0})),Re.load(fe,(e=>{Ce.roughness=e,e.repeat.set(1,25),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Ce.needsUpdate=!0})),Re.load(fe,(e=>{Se.roughness=e,e.repeat.set(1,1),e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,Se.needsUpdate=!0})),Re.load(ge,(e=>{Ce.aoMap=e,e.repeat.set(1,25),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Ce.needsUpdate=!0})),Re.load(ge,(e=>{Se.aoMap=e,e.repeat.set(1,1),e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,Se.needsUpdate=!0})),Re.load(ve,(e=>{Ce.normalMap=e,e.repeat.set(1,25),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Ce.needsUpdate=!0})),Re.load(ve,(e=>{Se.normalMap=e,e.repeat.set(1,1),e.wrapS=THREE.ClampToEdgeWrapping,e.wrapT=THREE.ClampToEdgeWrapping,Se.needsUpdate=!0}));const De={once:!0};AFRAME.registerSystem("portal",{dependencies:["fader-plus"],init:function(){this.teleporting=!1,this.characterController=this.el.systems["hubs-systems"].characterController,this.fader=this.el.systems["fader-plus"],this.waitForFetch=this.waitForFetch.bind(this)},getRoomURL:async function(e){let t=await this.getRoomHubId(e);return window.SSO.userInfo.rooms.length>e?"https://xr.realitymedia.digital/"+t:null},getRoomHubId:async function(e){return this.waitForFetch(),window.SSO.userInfo.rooms[e]},getCubeMap:async function(e,t){return this.waitForFetch(),t&&0!=t.length||(t="start"),["Right","Left","Top","Bottom","Front","Back"].map((i=>"https://resources.realitymedia.digital/data/roomPanos/"+e.toString()+"/"+t+"-"+i+".png"))},getCubeMapByName:async function(e,t){return t&&0!=t.length||(t="start"),["Right","Left","Top","Bottom","Front","Back"].map((i=>"https://resources.realitymedia.digital/data/roomPanos/"+e+"/"+t+"-"+i+".png"))},waitForFetch:function(){window.SSO.userInfo||setTimeout(this.waitForFetch,100)},teleportTo:async function(e){this.teleporting=!0,await this.fader.fadeOut(),e.getWorldQuaternion(we),e.getWorldDirection(Ee),e.getWorldPosition(ye),ye.add(Ee.multiplyScalar(3)),Te.makeRotationFromQuaternion(we),Te.setPosition(ye),this.characterController.travelByWaypoint(Te,!0,!1),await this.fader.fadeIn(),this.teleporting=!1}}),AFRAME.registerComponent("portal",{schema:{portalType:{default:""},portalTarget:{default:""},secondaryTarget:{default:""},color:{type:"color",default:null},materialTarget:{type:"string",default:null},drawDoor:{type:"boolean",default:!1},text:{type:"string",default:null},textPosition:{type:"vec3"},textSize:{type:"vec2"},textScale:{type:"number",default:1}},init:function(){this.system=window.APP.scene.systems.portal,this.updatePortal=this.updatePortal.bind(this),this.data.portalType.length>0?this.setPortalInfo(this.data.portalType,this.data.portalTarget,this.data.color):this.portalType=0,0==this.portalType&&this.parseNodeName(),this.portalTitle=null;let e=r(this.el,"gltf-model-plus");e&&e.addEventListener("model-loaded",(e=>{this.initialize()}),De)},initialize:async function(){if(this.materials=null,this.radius=.2,this.cubeMap=new THREE.CubeTexture,this.other=await this.getOther(),this.el.setAttribute("animation__portal",{property:"components.portal.radius",dur:700,easing:"easeInOutCubic"}),this.el.components["media-loader"]||this.el.components["media-image"])if(this.el.components["media-loader"]){let e=()=>{this.setupPortal(),this.data.drawDoor&&this.setupDoor(),this.el.removeEventListener("model-loaded",e)};this.el.addEventListener("media-loaded",e)}else this.setupPortal(),this.data.drawDoor&&this.setupDoor();else this.setupPortal(),this.data.drawDoor&&this.setupDoor()},updatePortal:async function(){2!=this.portalType&&3!=this.portalType||(function(e){let t=l(e);t&&(console.log("showing objects near "+t.el.className),c(t.region))}(this.el),this.cubeCamera.update(this.el.sceneEl.renderer,this.el.sceneEl.object3D),function(e){let t=l(e);t&&(console.log("hiding objects near "+t.el.className),h(t.region))}(this.el))},setupPortal:async function(){this.el.classList.contains("interactable")&&this.el.classList.remove("interactable"),this.el.removeAttribute("is-remote-hover-target");let t=this.data.materialTarget;if(t&&0==t.length&&(t=null),this.materials=de(he,this.el,t,{radius:this.radius,ringColor:this.color,cubeMap:this.cubeMap,invertWarpColor:1==this.portalType?1:0}),1==this.portalType&&null!=this.portalTarget)this.system.getCubeMap(this.portalTarget,this.data.secondaryTarget).then((e=>{new Promise(((t,i)=>(new THREE.CubeTextureLoader).load(e,t,void 0,i))).then((e=>{e.format=THREE.RGBFormat,this.cubeMap=e})).catch((e=>console.error(e)))}));else if(4==this.portalType)this.system.getCubeMapByName(this.portalTarget,this.data.secondaryTarget).then((e=>{new Promise(((t,i)=>(new THREE.CubeTextureLoader).load(e,t,void 0,i))).then((e=>{e.format=THREE.RGBFormat,this.cubeMap=e})).catch((e=>console.error(e)))}));else if(2==this.portalType||3==this.portalType){if(THREE.REVISION<125)this.cubeCamera=new be(.1,1e3,1024);else{const e=new THREE.WebGLCubeRenderTarget(1024,{encoding:THREE.sRGBEncoding,generateMipmaps:!0});this.cubeCamera=new be(1,1e5,e)}if(2==this.portalType)this.el.object3D.add(this.cubeCamera),this.other.components.portal.cubeMap=this.cubeCamera.renderTarget.texture;else{let e=document.getElementsByClassName(this.portalTarget);e.length>0&&(e=e.item(0),this.cubeCamera.position.y=1.6,this.cubeCamera.needsUpdate=!0,e.object3D.add(this.cubeCamera),this.cubeMap=this.cubeCamera.renderTarget.texture)}this.updatePortal(),this.el.sceneEl.addEventListener("updatePortals",this.updatePortal),this.el.sceneEl.addEventListener("model-loaded",this.updatePortal)}let i=new THREE.Quaternion,a=new THREE.Vector3,o=new THREE.Vector3;this.el.object3D.matrixWorld.decompose(o,i,a);let r=this.el.object3DMap.mesh.scale;if(this.Yoffset=-(a.y*r.y/2-1.6),this.close(),this.el.setAttribute("proximity-events",{radius:4,Yoffset:this.Yoffset}),this.el.addEventListener("proximityenter",(()=>this.open())),this.el.addEventListener("proximityleave",(()=>this.close())),this.el.setObject3D.matrixAutoUpdate=!0,this.data.text&&this.data.text.length>0){var n={width:this.data.textSize.x,height:this.data.textSize.y,message:this.data.text};const t=e.PortalTitle;this.portalTitle=t(n),this.portalTitle.waitForReady().then((()=>{this.el.setObject3D("portalTitle",this.portalTitle.webLayer3D),this.portalTitle.webLayer3D.matrixAutoUpdate=!0;let e=this.portalTitle.getSize(),t=a.x/this.data.textScale,i=a.y/this.data.textScale,o=a.z/this.data.textScale;this.portalTitle.webLayer3D.scale.x/=t,this.portalTitle.webLayer3D.scale.y/=i,this.portalTitle.webLayer3D.scale.z/=o,this.portalTitle.webLayer3D.position.x=this.data.textPosition.x/a.x,this.portalTitle.webLayer3D.position.y=.5*r.y+(this.data.drawDoor?.105:0)/a.y+e.height*this.data.textScale/2/a.y+this.data.textPosition.y/a.y,this.portalTitle.webLayer3D.position.z=this.data.textPosition.z/a.z}))}},remove:function(){this.el.sceneEl.removeEventListener("updatePortals",this.updatePortal),this.el.sceneEl.removeEventListener("model-loaded",this.updatePortal),this.portalTitle&&(this.el.removeObject3D("portalTitle"),this.portalTitle.destroy(),this.portalTitle=null),this.cubeMap&&(this.cubeMap.dispose(),this.cubeMap=null)},setupDoor:function(){let e=this.el.object3DMap.mesh.scale,t=new THREE.Quaternion,i=new THREE.Vector3,a=new THREE.Vector3;this.el.object3D.matrixWorld.decompose(a,t,i);var o=i.x*e.x,r=i.y*e.y,n=i.z*e.z;const s=this.el.sceneEl.components["environment-map"];let l=new THREE.Mesh(new THREE.BoxGeometry(.1/o,1,.099/n,2,5,2),[Ce,Ce,Se,Se,Ce,Ce]);s&&s.applyEnvironmentMap(l),l.position.set(-.51,0,0),this.el.object3D.add(l);let c=new THREE.Mesh(new THREE.BoxGeometry(.1/o,1,.099/n,2,5,2),[Ce,Ce,Se,Se,Ce,Ce]);s&&s.applyEnvironmentMap(c),c.position.set(.51,0,0),this.el.object3D.add(c);let h=new THREE.Mesh(new THREE.BoxGeometry(1+.3/o,.1/r,.1/n,2,5,2),[Se,Se,Ce,Ce,Ce,Ce]);s&&s.applyEnvironmentMap(h),h.position.set(0,.505,0),this.el.object3D.add(h)},tick:function(e){if(this.materials&&(this.portalTitle&&this.portalTitle.tick(e),this.materials.map((t=>{t.userData.radius=this.radius,t.userData.cubeMap=this.cubeMap,he.updateUniforms(e,t)})),this.other&&!this.system.teleporting)){if(this.el.sceneEl.camera.getWorldPosition(xe),this.el.object3D.worldToLocal(xe),Math.abs(xe.x)>.5||Math.abs(xe.y)>.5)return;const e=Math.abs(xe.z);if((1==this.portalType||4==this.portalType)&&e<.25){if(!this.locationhref)if(this.locationhref=this.other,APP.store.state.preferences.fastRoomSwitching){let e=this.data.secondaryTarget;document.querySelector("#environment-scene");let t=function(){e&&e.length>0&&(console.log("FAST ROOM SWITCH INCLUDES waypoint: setting hash to "+e),window.location.hash=e)};console.log("FAST ROOM SWITCH. going to "+this.hub_id),this.hubId===APP.hub.hub_id?(console.log("Same Room"),t()):window.changeHub(this.hub_id).then((()=>{t()}))}else console.log("set window.location.href to "+this.other),window.location.href=this.other}else 2==this.portalType&&e<.25?this.system.teleportTo(this.other.object3D):3==this.portalType&&(e<.25?this.locationhref||(console.log("set window.location.hash to "+this.other),this.locationhref=this.other,window.location.hash=this.other):this.locationhref=null)}},getOther:function(){return new Promise((e=>{if(0==this.portalType)e(null);else if(1==this.portalType)null!=this.portalTarget?this.system.getRoomHubId(this.portalTarget).then((t=>{this.hub_id=t,this.system.getRoomURL(this.portalTarget).then((t=>{this.data.secondaryTarget&&this.data.secondaryTarget.length>0?e(t+"#"+this.data.secondaryTarget):e(t)}))})):e(null);else if(2==this.portalType){const t=Array.from(document.querySelectorAll("[portal]")).find((e=>e.components.portal.portalType==this.portalType&&e.components.portal.portalTarget===this.portalTarget&&e!==this.el));void 0!==t?(e(t),t.emit("pair",{other:this.el})):this.el.addEventListener("pair",(t=>{e(t.detail.other)}),{once:!0})}else if(3==this.portalType)e("#"+this.portalTarget);else if(4==this.portalType){let t=window.location.origin+"/"+this.portalTarget;this.hub_id=this.portalTarget,this.data.secondaryTarget&&this.data.secondaryTarget.length>0?e(t+"#"+this.data.secondaryTarget):e(t)}}))},parseNodeName:function(){const e=this.el.parentEl.parentEl.className,t=e.match(/([A-Za-z]*)_([A-Za-z0-9]*)_([A-Za-z0-9]*)$/);if(!t||t.length<4)return console.warn("portal node name not formed correctly: ",e),this.portalType=0,this.portalTarget=null,void(this.color="red");this.setPortalInfo(t[1],t[2],t[3])},setPortalInfo:function(e,t,i){"room"===e?(this.portalType=1,t.length>0?this.portalTarget=parseInt(t):this.portalTarget=null):"portal"===e?(this.portalType=2,this.portalTarget=t):"waypoint"===e?(this.portalType=3,this.portalTarget=t):"roomName"===e?(this.portalType=4,this.portalTarget=t):(this.portalType=0,this.portalTarget=null),this.color=new THREE.Color(i)},setRadius(e){this.el.setAttribute("animation__portal",{from:this.radius,to:e})},open(){this.setRadius(1)},close(){this.setRadius(.2)},isClosed(){return.2===this.radius}});const Me=new THREE.Vector3,He=new THREE.Vector3,_e=new THREE.TextureLoader;var Ae=null;_e.load("https://ymastin3.github.io/core-components/e1702ea21afb4a86.png",(e=>{e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,Ae=e})),AFRAME.registerSystem("immersive-360",{init:function(){this.updateThis=null},updatePosition(e){this.updateThis=e},tick:function(){this.updateThis&&(this.updateThis.el.sceneEl.camera.updateMatrices(),this.updateThis.el.sceneEl.camera.getWorldPosition(Me),this.updateThis.el.object3D.worldToLocal(Me),this.updateThis.mesh.position.copy(Me),this.updateThis.mesh.matrixNeedsUpdate=!0,this.updateThis.mesh.updateWorldMatrix(!0,!1))}}),AFRAME.registerComponent("immersive-360",{schema:{url:{type:"string",default:null},radius:{type:"number",default:.15}},init:async function(){this.system=window.APP.scene.systems["immersive-360"];var e=this.data.url;e&&""!=e||(e=this.parseSpokeName());const t=e.match(/^.*\.(.*)$/)[1];this.pano=document.createElement("a-entity"),this.pano.setAttribute("media-image",{projection:"360-equirectangular",alphaMode:"opaque",src:e,version:1,batch:!1,contentType:`image/${t}`,alphaCutoff:0}),this.el.appendChild(this.pano),this.mesh=await this.getMesh(),this.mesh.matrixAutoUpdate=!0,this.mesh.updateWorldMatrix(!0,!1);var i=new THREE.Mesh(new THREE.SphereBufferGeometry(this.data.radius,30,20),new THREE.ShaderMaterial({uniforms:{panotex:{value:this.mesh.material.map},texfx:{value:Ae},selected:{value:0},ballTime:{value:0}},vertexShader:"\nvarying vec2 ballvUv;\nvarying vec3 ballvPosition;\nvarying vec3 ballvNormal;\nvarying vec3 ballvWorldPos;\nuniform float ballTime;\nuniform float selected;\n\nmat4 ballinverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\nmat4 balltranspose(in mat4 m) {\n  vec4 i0 = m[0];\n  vec4 i1 = m[1];\n  vec4 i2 = m[2];\n  vec4 i3 = m[3];\n\n  return mat4(\n    vec4(i0.x, i1.x, i2.x, i3.x),\n    vec4(i0.y, i1.y, i2.y, i3.y),\n    vec4(i0.z, i1.z, i2.z, i3.z),\n    vec4(i0.w, i1.w, i2.w, i3.w)\n  );\n}\n\nvoid main()\n{\n  ballvUv = uv;\n\n  ballvPosition = position;\n\n  vec3 offset = vec3(\n    sin(position.x * 50.0 + ballTime),\n    sin(position.y * 10.0 + ballTime * 2.0),\n    cos(position.z * 40.0 + ballTime)\n  ) * 0.003;\n\n   ballvPosition *= 1.0 + selected * 0.2;\n\n   ballvNormal = normalize(ballinverse(balltranspose(modelMatrix)) * vec4(normalize(normal), 1.0)).xyz;\n   ballvWorldPos = (modelMatrix * vec4(ballvPosition, 1.0)).xyz;\n\n   vec4 ballvPosition = modelViewMatrix * vec4(ballvPosition + offset, 1.0);\n\n  gl_Position = projectionMatrix * ballvPosition;\n}\n",fragmentShader:"\nuniform sampler2D panotex;\nuniform sampler2D texfx;\nuniform float ballTime;\nuniform float selected;\nvarying vec2 ballvUv;\nvarying vec3 ballvPosition;\nvarying vec3 ballvNormal;\nvarying vec3 ballvWorldPos;\n\nuniform float opacity;\n\nvoid main( void ) {\n   vec2 uv = ballvUv;\n  //uv.y =  1.0 - uv.y;\n\n   vec3 eye = normalize(cameraPosition - ballvWorldPos);\n   float fresnel = abs(dot(eye, ballvNormal));\n   float shift = pow((1.0 - fresnel), 4.0) * 0.05;\n\n  vec3 col = vec3(\n    texture2D(panotex, uv - shift).r,\n    texture2D(panotex, uv).g,\n    texture2D(panotex, uv + shift).b\n  );\n\n   col = mix(col * 0.7, vec3(1.0), 0.7 - fresnel);\n\n   col += selected * 0.3;\n\n   float t = ballTime * 0.4 + ballvPosition.x + ballvPosition.z;\n   uv = vec2(ballvUv.x + t * 0.2, ballvUv.y + t);\n   vec3 fx = texture2D(texfx, uv).rgb * 0.4;\n\n  //vec4 col = vec4(1.0, 1.0, 0.0, 1.0);\n  gl_FragColor = vec4(col + fx, opacity);\n  //gl_FragColor = vec4(col + fx, 1.0);\n}\n",side:THREE.BackSide}));i.rotation.set(Math.PI,Math.PI,0),i.userData.floatY=this.data.radius>1.5?this.data.radius+.1:1.6,i.userData.selected=0,i.userData.timeOffset=10*(Math.random()+.5),this.ball=i,this.el.setObject3D("ball",i),this.mesh.material.setValues({transparent:!0,depthTest:!1}),this.mesh.visible=!1,this.near=this.data.radius-0,this.far=this.data.radius+.05,this.mesh.renderOrder=APP.RENDER_ORDER.CURSOR-.1},remove:function(){this.ball.geometry.dispose(),this.ball.geometry=null,this.ball.material.dispose(),this.ball.material=null,this.el.removeObject3D("ball"),this.ball=null},tick:function(e){if(this.mesh&&Ae){let t=.02*Math.cos((e+this.ball.userData.timeOffset)/1e3*3);this.ball.position.y=this.ball.userData.floatY+t,this.ball.matrixNeedsUpdate=!0,this.ball.material.uniforms.texfx.value=Ae,this.ball.material.uniforms.ballTime.value=.001*e+this.ball.userData.timeOffset,this.ball.getWorldPosition(He),this.el.sceneEl.camera.getWorldPosition(Me);const i=1-(He.distanceTo(Me)-this.near)/(this.far-this.near);i<0?(this.mesh.visible=!1,this.mesh.material.opacity=1,this.ball.material.opacity=1):(this.mesh.material.opacity=i>1?1:i,this.mesh.visible=!0,this.ball.material.opacity=this.mesh.material.opacity,this.system.updatePosition(this))}},parseSpokeName:function(){const e=this.el.parentEl.parentEl.className.match(/(?:.*__)?(.*)_(.*)/);if(!e||e.length<3)return"";const[,t,i]=e;return`https://resources.realitymedia.digital/data/${t}.${i}`},getMesh:async function(){return new Promise((e=>{const t=this.pano.object3DMap.mesh;t&&e(t),this.pano.addEventListener("image-loaded",(()=>{console.log("immersive-360 pano loaded: "+this.data.url),e(this.pano.object3DMap.mesh)}),{once:!0})}))}});const Pe=String.raw,Ne={modes:{none:"NO_PARALLAX",basic:"USE_BASIC_PARALLAX",steep:"USE_STEEP_PARALLAX",occlusion:"USE_OCLUSION_PARALLAX",relief:"USE_RELIEF_PARALLAX"},uniforms:{bumpMap:{value:null},map:{value:null},parallaxScale:{value:null},parallaxMinLayers:{value:null},parallaxMaxLayers:{value:null}},vertexShader:Pe`
    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    void main() {
      vUv = uv;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      vViewPosition = -mvPosition.xyz;
      vNormal = normalize( normalMatrix * normal );
      
      gl_Position = projectionMatrix * mvPosition;
    }
  `,fragmentShader:Pe`
    uniform sampler2D bumpMap;
    uniform sampler2D map;

    uniform float parallaxScale;
    uniform float parallaxMinLayers;
    uniform float parallaxMaxLayers;
    uniform float fade; // CUSTOM

    varying vec2 vUv;
    varying vec3 vViewPosition;
    varying vec3 vNormal;

    #ifdef USE_BASIC_PARALLAX

    vec2 parallaxMap(in vec3 V) {
      float initialHeight = texture2D(bumpMap, vUv).r;

      // No Offset Limitting: messy, floating output at grazing angles.
      //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

      // Offset Limiting
      vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;
      return vUv - texCoordOffset;
    }

    #else

    vec2 parallaxMap(in vec3 V) {
      // Determine number of layers from angle between V and N
      float numLayers = mix(parallaxMaxLayers, parallaxMinLayers, abs(dot(vec3(0.0, 0.0, 1.0), V)));

      float layerHeight = 1.0 / numLayers;
      float currentLayerHeight = 0.0;
      // Shift of texture coordinates for each iteration
      vec2 dtex = parallaxScale * V.xy / V.z / numLayers;

      vec2 currentTextureCoords = vUv;

      float heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;

      // while ( heightFromTexture > currentLayerHeight )
      // Infinite loops are not well supported. Do a "large" finite
      // loop, but not too large, as it slows down some compilers.
      for (int i = 0; i < 30; i += 1) {
        if (heightFromTexture <= currentLayerHeight) {
          break;
        }
        currentLayerHeight += layerHeight;
        // Shift texture coordinates along vector V
        currentTextureCoords -= dtex;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
      }

      #ifdef USE_STEEP_PARALLAX

      return currentTextureCoords;

      #elif defined(USE_RELIEF_PARALLAX)

      vec2 deltaTexCoord = dtex / 2.0;
      float deltaHeight = layerHeight / 2.0;

      // Return to the mid point of previous layer
      currentTextureCoords += deltaTexCoord;
      currentLayerHeight -= deltaHeight;

      // Binary search to increase precision of Steep Parallax Mapping
      const int numSearches = 5;
      for (int i = 0; i < numSearches; i += 1) {
        deltaTexCoord /= 2.0;
        deltaHeight /= 2.0;
        heightFromTexture = texture2D(bumpMap, currentTextureCoords).r;
        // Shift along or against vector V
        if (heightFromTexture > currentLayerHeight) {
          // Below the surface

          currentTextureCoords -= deltaTexCoord;
          currentLayerHeight += deltaHeight;
        } else {
          // above the surface

          currentTextureCoords += deltaTexCoord;
          currentLayerHeight -= deltaHeight;
        }
      }
      return currentTextureCoords;

      #elif defined(USE_OCLUSION_PARALLAX)

      vec2 prevTCoords = currentTextureCoords + dtex;

      // Heights for linear interpolation
      float nextH = heightFromTexture - currentLayerHeight;
      float prevH = texture2D(bumpMap, prevTCoords).r - currentLayerHeight + layerHeight;

      // Proportions for linear interpolation
      float weight = nextH / (nextH - prevH);

      // Interpolation of texture coordinates
      return prevTCoords * weight + currentTextureCoords * (1.0 - weight);

      #else // NO_PARALLAX

      return vUv;

      #endif
    }
    #endif

    vec2 perturbUv(vec3 surfPosition, vec3 surfNormal, vec3 viewPosition) {
      vec2 texDx = dFdx(vUv);
      vec2 texDy = dFdy(vUv);

      vec3 vSigmaX = dFdx(surfPosition);
      vec3 vSigmaY = dFdy(surfPosition);
      vec3 vR1 = cross(vSigmaY, surfNormal);
      vec3 vR2 = cross(surfNormal, vSigmaX);
      float fDet = dot(vSigmaX, vR1);

      vec2 vProjVscr = (1.0 / fDet) * vec2(dot(vR1, viewPosition), dot(vR2, viewPosition));
      vec3 vProjVtex;
      vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;
      vProjVtex.z = dot(surfNormal, viewPosition);

      return parallaxMap(vProjVtex);
    }

    void main() {
      vec2 mapUv = perturbUv(-vViewPosition, normalize(vNormal), normalize(vViewPosition));
      
      // CUSTOM START
      vec4 texel = texture2D(map, mapUv);
      vec3 color = mix(texel.xyz, vec3(0), fade);
      gl_FragColor = vec4(color, 1.0);
      // CUSTOM END
    }

  `},Le=new THREE.Vector3,ze=new THREE.Vector3(0,0,1);AFRAME.registerComponent("parallax",{schema:{strength:{type:"number",default:.5},cutoffTransition:{type:"number",default:Math.PI/8},cutoffAngle:{type:"number",default:Math.PI/4}},init:function(){const e=this.el.object3DMap.mesh,{map:t,emissiveMap:i}=e.material;t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping,i.wrapS=i.wrapT=THREE.ClampToEdgeWrapping;const{vertexShader:a,fragmentShader:o}=Ne;this.material=new THREE.ShaderMaterial({vertexShader:a,fragmentShader:o,defines:{USE_OCLUSION_PARALLAX:!0},uniforms:{map:{value:t},bumpMap:{value:i},parallaxScale:{value:-1*this.data.strength},parallaxMinLayers:{value:20},parallaxMaxLayers:{value:30},fade:{value:0}}}),e.material=this.material},tick(){if(this.el.sceneEl.camera){this.el.sceneEl.camera.getWorldPosition(Le),this.el.object3D.worldToLocal(Le);const l=Le.angleTo(ze),c=(e=l,t=this.data.cutoffAngle-this.data.cutoffTransition,i=this.data.cutoffAngle+this.data.cutoffTransition,r=function(e,t,i,a,o){return a+(e-t)*(o-a)/(i-t)}(e,t,i,a=0,o=1),n=a,s=o,Math.max(n,Math.min(s,r)));this.material.uniforms.fade.value=c}var e,t,i,a,o,r,n,s}});const ke=new THREE.TextureLoader,je=new THREE.PlaneGeometry(1,1),Fe=new THREE.MeshBasicMaterial({transparent:!0,alphaTest:.1});ke.load("https://ymastin3.github.io/core-components/f98b96fe3e06ea20.png",(e=>{Fe.map=e,Fe.needsUpdate=!0})),AFRAME.registerSystem("html-script",{init(){this.systemTick=e.systemTick,this.initializeEthereal=e.initializeEthereal,this.systemTick&&this.initializeEthereal?this.initializeEthereal():console.error("error in html-script system: htmlComponents has no systemTick and/or initializeEthereal methods")},tick(e,t){this.systemTick(e,t)}});const Oe={once:!0};AFRAME.registerComponent("html-script",{schema:{name:{type:"string",default:""},width:{type:"number",default:-1},height:{type:"number",default:-1},parameter1:{type:"string",default:""},parameter2:{type:"string",default:""},parameter3:{type:"string",default:""},parameter4:{type:"string",default:""}},init:function(){this.script=null,this.fullName=this.data.name,this.scriptData={width:this.data.width,height:this.data.height,parameter1:this.data.parameter1,parameter2:this.data.parameter2,parameter3:this.data.parameter3,parameter4:this.data.parameter4},this.loading=!0,this.spinnerPlane=new THREE.Mesh(je,Fe),this.spinnerPlane.matrixAutoUpdate=!0,this.spinnerPlane.position.z=.05,this.fullName&&0!=this.fullName.length?this.componentName=this.fullName:this.parseNodeName();let e=r(this.el,"gltf-model-plus");e&&e.addEventListener("model-loaded",(e=>{this.createScript()}),Oe)},update:function(){""!==this.data.name&&this.data.name!==this.fullName&&(this.fullName=this.data.name,this.componentName=this.fullName,this.script&&this.destroyScript(),this.createScript())},createScript:function(){let e=()=>{this.loadScript().then((()=>{if(!this.script)return;this.script.isNetworked&&(this.netEntity=null,this.getSharedData=this.getSharedData.bind(this),this.takeOwnership=this.takeOwnership.bind(this),this.setSharedData=this.setSharedData.bind(this),this.script.setNetworkMethods(this.takeOwnership,this.setSharedData));const e=document.createElement("a-entity");this.simpleContainer=e,this.simpleContainer.object3D.matrixAutoUpdate=!0,this.simpleContainer.setObject3D("weblayer3d",this.script.webLayer3D);var t=1,i=1;if(this.el.components["media-image"]){let e=this.el.object3DMap.mesh.scale,a=this.el.object3D.scale;t=e.x*a.x,i=e.y*a.y,a.x=1,a.y=1,a.z=1,this.el.object3D.matrixNeedsUpdate=!0}else{let e=this.el.object3DMap.mesh;if(e){let a=e.geometry.boundingBox;t=(a.max.x-a.min.x)*e.scale.x,i=(a.max.y-a.min.y)*e.scale.y}else{let e=this.el.object3D.scale;t=e.x,i=e.y,e.x=1,e.y=1,e.z=1,this.el.object3D.matrixNeedsUpdate=!0}var a=this.el.parentEl.parentEl.object3D;t*=a.scale.x,i*=a.scale.y,a.scale.x=1,a.scale.y=1,a.scale.z=1,a.matrixNeedsUpdate=!0}if(this.actualWidth=t,this.actualHeight=i,t>0&&i>0){const{width:e,height:a}=this.script.getSize();if(e>0&&a>0){var o=Math.min(t/e,i/a);this.simpleContainer.setAttribute("scale",{x:o,y:o,z:o})}const r=.25*Math.min(t,i);this.spinnerPlane.scale.set(r,r,1)}for(const e of this.el.object3D.children)e.visible=!1;this.script.isStatic&&(this.script.isInteractive||this.script.isNetworked)&&(this.script.isStatic=!1),this.el.appendChild(this.simpleContainer),this.el.setObject3D("spinner",this.spinnerPlane),this.script.isInteractive?(this.el.classList.contains("interactable"),this.simpleContainer.setAttribute("is-remote-hover-target",""),this.simpleContainer.setAttribute("tags",{singleActionButton:!0,inspectable:!0,isStatic:!0,togglesHoveredActionSet:!0}),this.simpleContainer.setAttribute("class","interactable"),this.clicked=this.clicked.bind(this),this.simpleContainer.object3D.addEventListener("interact",this.clicked),this.script.isDraggable&&(this.simpleContainer.setAttribute("tags",{singleActionButton:!0,isHoldable:!0,holdableButton:!0,inspectable:!0,isStatic:!0,togglesHoveredActionSet:!0}),this.simpleContainer.object3D.addEventListener("holdable-button-down",(e=>{this.script.dragStart(e)})),this.simpleContainer.object3D.addEventListener("holdable-button-up",(e=>{this.script.dragEnd(e)}))),this.hoverRayL=new THREE.Ray,this.hoverRayR=new THREE.Ray):(this.el.classList.contains("interactable")&&this.el.classList.remove("interactable"),this.el.removeAttribute("is-remote-hover-target")),this.el.hasAttribute("networked")&&this.el.removeAttribute("networked"),this.script.isNetworked&&(this.setupNetworkedEntity=function(e){var t,i,a=!0;e?(t=NAF.utils.getNetworkId(e)+"-html-script",a=i.components.networked.data.persistent):t=this.fullName.replaceAll("_","-")+"-html-script",NAF.entities.hasEntity(t)?i=NAF.entities.getEntity(t):((i=document.createElement("a-entity")).getSharedData=this.getSharedData,i.setAttribute("networked",{template:"#script-data-media",persistent:a,owner:"scene",networkId:t}),this.el.sceneEl.appendChild(i)),this.netEntity=i,NAF.utils.getNetworkedEntity(this.netEntity).then((e=>{this.stateSync=e.components["script-data"],2==this.stateSync.sharedData.length&&e.components.networked}))},this.setupNetworkedEntity=this.setupNetworkedEntity.bind(this),this.setupNetworked=function(){NAF.utils.getNetworkedEntity(this.el).then((e=>{this.setupNetworkedEntity(e)})).catch((()=>{this.setupNetworkedEntity()}))},this.setupNetworked=this.setupNetworked.bind(this),NAF.connection&&NAF.connection.isConnected()?this.setupNetworked():this.el.sceneEl.addEventListener("didConnectToNetworkedScene",this.setupNetworked))})).catch((e=>{console.error("loadScript failed for script "+this.data.name+": "+e)}))};this.el.components["media-loader"]?this.el.addEventListener("media-loaded",(()=>{e()}),{once:!0}):e()},play:function(){this.script&&this.script.play()},pause:function(){this.script&&this.script.pause()},clicked:function(e){console.log("clicked on html: ",e),this.script.clicked(e)},takeOwnership:function(){return!this.stateSync||this.stateSync.takeOwnership()},setSharedData:function(e){return!this.stateSync||this.stateSync.setSharedData(e)},getSharedData:function(){return this.script?this.script.getSharedData():(console.warn("script-data component called parent element but there is no script yet?"),"{}")},tick:function(e){if(this.script)if(this.loading)this.spinnerPlane.rotation.z+=.03;else{if(this.script.isInteractive){const e=this.el.sceneEl.systems["hubs-systems"].cursorTogglingSystem;var t=[];let i,a;const o=this.el.sceneEl.systems.interaction;if(!o.ready)return;let r=this.simpleContainer;if(o.state.leftHand.hovered!==r||o.state.leftHand.held||(i=o.options.leftHand.entity.object3D),o.state.leftRemote.hovered!==r||o.state.leftRemote.held||e.leftToggledOff||(i=o.options.leftRemote.entity.object3D),i){let e=i.position,a=this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate();e.addScaledVector(a,-.1),this.hoverRayL.set(e,a),t.push(this.hoverRayL)}if(o.state.rightRemote.hovered!==r||o.state.rightRemote.held||e.rightToggledOff||(a=o.options.rightRemote.entity.object3D),o.state.rightHand.hovered!==r||o.state.rightHand.held||(a=o.options.rightHand.entity.object3D),a){let e=a.position,i=this.script.webLayer3D.getWorldDirection(new THREE.Vector3).negate();e.addScaledVector(i,-.1),this.hoverRayR.set(e,i),t.push(this.hoverRayR)}this.script.webLayer3D.interactionRays=t}if(this.script.isNetworked){if(!this.netEntity||!this.stateSync)return;this.stateSync.changed&&(this.stateSync.changed=!1,this.script.updateSharedData(this.stateSync.dataObject))}this.script.tick(e)}},parseNodeName:function(){""===this.fullName&&(this.fullName=this.el.parentEl.parentEl.className);const e=this.fullName.match(/_([A-Za-z0-9]*)$/);!e||e.length<2?(console.warn("html-script componentName not formatted correctly: ",this.fullName),this.componentName=null):this.componentName=e[1]},loadScript:async function(){var t=e[this.componentName];if(!t)return console.warn("'html-script' component doesn't have script for "+this.componentName),void(this.script=null);try{this.script=t(this.scriptData)}catch(e){console.error("error creating script for "+this.componentName,e),this.script=null}this.script?(this.script.needsUpdate=!0,this.script.waitForReady().then((()=>{const{width:e,height:t}=this.script.getSize();if(e>0&&t>0){var i=Math.min(this.actualWidth/e,this.actualHeight/t);this.simpleContainer.setAttribute("scale",{x:i,y:i,z:i})}this.el.sceneEl.emit("updatePortals"),this.loading=!1,this.el.removeObject3D("spinner")}))):console.warn("'html-script' component failed to initialize script for "+this.componentName)},remove:function(){this.destroyScript()},destroyScript:function(){this.script.isInteractive&&this.simpleContainer.object3D.removeEventListener("interact",this.clicked),window.APP.scene.removeEventListener("didConnectToNetworkedScene",this.setupNetworked),this.el.removeChild(this.simpleContainer),this.simpleContainer.removeObject3D("weblayer3d"),this.simpleContainer=null,this.script.isNetworked&&this.netEntity.parentNode&&this.netEntity.parentNode.removeChild(this.netEntity),this.script.destroy(),this.script=null}}),AFRAME.registerComponent("script-data",{schema:{scriptdata:{type:"string",default:"{}"}},init:function(){this.takeOwnership=this.takeOwnership.bind(this),this.setSharedData=this.setSharedData.bind(this),this.dataObject=this.el.getSharedData();try{this.sharedData=encodeURIComponent(JSON.stringify(this.dataObject)),this.el.setAttribute("script-data","scriptdata",this.sharedData)}catch(e){console.error("Couldn't encode initial script data object: ",e,this.dataObject),this.sharedData="{}",this.dataObject={}}this.changed=!1},update(){if(this.changed=!(this.sharedData===this.data.scriptdata),this.changed)try{this.dataObject=JSON.parse(decodeURIComponent(this.data.scriptdata)),this.sharedData=this.data.scriptdata,this.changed=!0}catch(e){console.error("couldn't parse JSON received in script-sync: ",e),this.sharedData="{}",this.dataObject={}}},play(){this.el.components.networked&&APP.utils&&APP.utils.applyPersistentSync(this.el.components.networked.data.networkId)},takeOwnership(){return!(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))},setSharedData(e){if(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))return!1;try{var t=encodeURIComponent(JSON.stringify(e));return this.sharedData=t,this.dataObject=e,this.el.setAttribute("script-data","scriptdata",t),!0}catch(e){return console.error("can't stringify the object passed to script-sync"),!1}}});document.querySelector("a-assets").insertAdjacentHTML("beforeend",'\n    <template id="script-data-media">\n      <a-entity\n        script-data\n      ></a-entity>\n    </template>\n  '),NAF.schemas.add({template:"#script-data-media",components:[{component:"script-data",property:"scriptdata"}],nonAuthorizedComponents:[{component:"script-data",property:"scriptdata"}]}),AFRAME.registerComponent("video-control-pad",{mediaVideo:{},schema:{target:{type:"string",default:""},radius:{type:"number",default:1}},init:function(){if(0==this.data.target.length)return void console.warn("video-control-pad must have 'target' set");let e=r(this.el,"gltf-model-plus");e&&e.addEventListener("model-loaded",(()=>{this.initialize()}))},initialize:function(){var e;let t=null===(e=this.el.sceneEl)||void 0===e?void 0:e.object3D.getObjectByName(this.data.target);if(null!=t)if(t.el.components["media-loader"]||t.el.components["media-video"])if(t.el.components["media-loader"]){let e=()=>{this.setupVideoPad(t),t.el.removeEventListener("model-loaded",e)};t.el.addEventListener("media-loaded",e)}else this.setupVideoPad(t);else console.warn("video-control-pad target '"+this.data.target+"' is not a video element");else console.warn("video-control-pad target '"+this.data.target+"' does not exist")},setupVideoPad:function(e){this.mediaVideo=e.el.components["media-video"],null==this.mediaVideo&&console.warn("video-control-pad target '"+this.data.target+"' is not a video element"),this.el.setAttribute("proximity-events",{radius:this.data.radius,Yoffset:1.6}),this.el.addEventListener("proximityenter",(()=>this.enterRegion())),this.el.addEventListener("proximityleave",(()=>this.leaveRegion()))},enterRegion:function(){this.mediaVideo.data.videoPaused&&this.mediaVideo.togglePlaying()},leaveRegion:function(){this.mediaVideo.data.videoPaused||this.mediaVideo.togglePlaying()}}),new THREE.Vector3,new THREE.Quaternion;const Ie=(new THREE.Matrix4).identity();function Ve(e,t){e.matrixIsModified||e.applyMatrix(Ie),e.matrixWorld.copy(t),e.parent?(e.parent.updateMatrices(),e.matrix=e.matrix.getInverse(e.parent.matrixWorld).multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale),e.childrenNeedMatrixWorldUpdate=!0}!function(){const e=new THREE.Matrix4,t={position:new THREE.Vector3,quaternion:new THREE.Quaternion,scale:new THREE.Vector3},i={position:new THREE.Vector3,quaternion:new THREE.Quaternion,scale:new THREE.Vector3},a={position:new THREE.Vector3,quaternion:new THREE.Quaternion,scale:new THREE.Vector3}}(),function(){const e=new THREE.Vector3,t=new THREE.Vector3}();!function(){const e=new THREE.Matrix4,t=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Vector3,o=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Matrix4}();!function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,i=new THREE.Matrix4}(),function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,i=new THREE.Matrix4,a=new THREE.Vector3}(),function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,i=new THREE.Matrix4,a=new THREE.Matrix4}();const Ue=function(){const e=new THREE.Matrix4,t=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Vector3,o=new THREE.Vector3,r=new THREE.Vector3;return function(n,s){return n.updateMatrices(),r.setFromMatrixPosition(n.matrixWorld),s.updateMatrices(),o.setFromMatrixPosition(s.matrixWorld),i.subVectors(o,r),i.y=0,i.normalize(),t.set(0,1,0),a.crossVectors(i,t),e.makeBasis(a,t,i.multiplyScalar(-1)),e.elements[12]=o.x,e.elements[13]=o.y,e.elements[14]=o.z,e}}(),We=new THREE.Mesh(new THREE.PlaneBufferGeometry(1e5,1e5,2,2),new THREE.MeshBasicMaterial({visible:!0,wireframe:!1,side:THREE.DoubleSide,transparent:!0,opacity:.3})),Be=new THREE.Mesh(new THREE.PlaneBufferGeometry(1e5,1e5,2,2),new THREE.MeshBasicMaterial({visible:!0,wireframe:!1,side:THREE.DoubleSide,transparent:!0,opacity:.3}));class qe{constructor(e){this.el=e,this.isDragging=!1,this.dragInteractor=null,this.planeRotation=new THREE.Matrix4,this.planeUp=new THREE.Vector3,this.planeRight=new THREE.Vector3,this.intersections=[],this.initialIntersectionPoint=new THREE.Vector3,this.intersectionPoint=new THREE.Vector3,this.delta={x:0,y:0},this.objectMatrix=new THREE.Matrix4,this.dragVector=new THREE.Vector3,this.camPosition=new THREE.Vector3,this.objectPosition=new THREE.Vector3,this.objectToCam=new THREE.Vector3}getInteractors(e){let t=this.el.sceneEl.systems["hubs-systems"].cursorTogglingSystem;const i=this.el.sceneEl.systems.interaction;var a=[];let o,r;if(!i.ready)return;let n=e;return i.state.leftHand.hovered!==n||i.state.leftHand.held||(o={cursor:i.options.leftHand.entity.object3D,controller:i.leftCursorControllerEl.components["cursor-controller"]}),i.state.leftRemote.hovered!==n||i.state.leftRemote.held||t.leftToggledOff||(o={cursor:i.options.leftRemote.entity.object3D,controller:i.leftCursorControllerEl.components["cursor-controller"]}),o&&a.push(o),i.state.rightRemote.hovered!==n||i.state.rightRemote.held||t.rightToggledOff||(r={cursor:i.options.rightRemote.entity.object3D,controller:i.rightCursorControllerEl.components["cursor-controller"]}),i.state.rightHand.hovered!==n||i.state.rightHand.held||(r={cursor:i.options.rightHand.entity.object3D,controller:i.rightCursorControllerEl.components["cursor-controller"]}),r&&a.push(r),a}getRefs(){if(!this.didGetObjectReferences){this.didGetObjectReferences=!0;const e=this.el.sceneEl.systems.interaction;this.leftEventer=e.options.leftRemote.entity.object3D,this.leftCursorController=e.leftCursorControllerEl.components["cursor-controller"],this.leftRaycaster=this.leftCursorController.raycaster,this.rightCursorController=e.rightCursorControllerEl.components["cursor-controller"],this.rightRaycaster=this.rightCursorController.raycaster,this.viewingCamera=document.getElementById("viewing-camera").object3DMap.camera}}getIntersection(e,t){this.getRefs();let i=(e.cursor===this.leftEventer?this.leftRaycaster:this.rightRaycaster).intersectObjects(t,!0);return i.length>0?i[0]:null}startDrag(e,t,i){if(this.isDragging)return!1;if(this.getRefs(),t=t||this.el.object3D,this.raycaster=e.object3D===this.leftEventer?this.leftRaycaster:this.rightRaycaster,i)this.plane=null;else if(this.plane=e.object3D===this.leftEventer?We:Be,Ve(this.plane,Ue(this.viewingCamera,t)),this.planeRotation.extractRotation(this.plane.matrixWorld),this.planeUp.set(0,1,0).applyMatrix4(this.planeRotation),this.planeRight.set(1,0,0).applyMatrix4(this.planeRotation),!(i=this.raycastOnPlane()))return!1;return this.isDragging=!0,this.dragInteractor={cursor:e.object3D,controller:e.object3D===this.leftEventer?this.leftCursorController:this.rightCursorController},this.initialIntersectionPoint.copy(i.point),this.initialDistanceToObject=this.objectToCam.subVectors(this.camPosition.setFromMatrixPosition(this.viewingCamera.matrixWorld),this.objectPosition.setFromMatrixPosition(t.matrixWorld)).length(),this.intersectionRight=0,this.intersectionUp=0,this.delta={x:0,y:0},!0}endDrag(e){this.isDragging&&(e.object3D===this.leftEventer&&this.raycaster===this.leftRaycaster||e.object3D!==this.leftEventer&&this.raycaster===this.rightRaycaster)&&(this.isDragging=!1,this.dragInteractor=null)}raycastOnPlane(){this.intersections.length=0;const e=this.raycaster.far;return this.raycaster.far=1e3,this.plane.raycast(this.raycaster,this.intersections),this.raycaster.far=e,this.intersections[0]}drag(){if(!this.isDragging)return null;if(this.plane){const e=this.raycastOnPlane();if(!e)return null;this.intersectionPoint.copy(e.point)}else this.intersectionPoint=this.raycaster.ray.origin.clone(),this.intersectionPoint.addScaledVector(this.raycaster.ray.direction,this.initialDistanceToObject);return this.dragVector.subVectors(this.intersectionPoint,this.initialIntersectionPoint),this.delta.x=this.plane?this.dragVector.dot(this.planeUp):this.dragVector.x,this.delta.y=this.plane?this.dragVector.dot(this.planeRight):this.dragVector.y,this.dragVector}}function Ye(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i&&Math.abs(e.z-t.z)<i}let Ge=function(e){return{startInit:function(){this.fullName=this.el.parentEl.parentEl.className,this.relativeSize=1,this.isDraggable=!1,this.isInteractive=!1,this.isNetworked=!1,this.internalClicked=this.internalClicked.bind(this),this.internalDragStart=this.internalDragStart.bind(this),this.internalDragEnd=this.internalDragEnd.bind(this)},finishInit:function(){let e=r(this.el,"gltf-model-plus");e&&e.addEventListener("model-loaded",(e=>{this.internalInit()}))},internalClicked:function(e){this.clicked&&this.clicked(e)},internalDragStart:function(e){this.dragStart(e)},internalDragEnd:function(e){this.dragEnd(e)},removeTemplate:function(){this.isInteractive&&this.simpleContainer.object3D.removeEventListener("interact",this.internalClicked),this.el.removeChild(this.simpleContainer),this.simpleContainer=null,this.isNetworked&&this.netEntity.parentNode&&this.netEntity.parentNode.removeChild(this.netEntity)},internalInit:function(){let t=()=>{this.loadData().then((()=>{this.isNetworked&&(this.netEntity=null,this.getSharedData=this.getSharedData.bind(this),this.setSharedData=this.setSharedData.bind(this)),this.simpleContainer=document.createElement("a-entity"),this.simpleContainer.object3D.matrixAutoUpdate=!0,this.initializeData();var t=1,i=1;if(this.el.components["media-image"]){let e=this.el.object3DMap.mesh.scale,a=this.el.object3D.scale;t=e.x*a.x,i=e.y*a.y,a.x=1,a.y=1,a.z=1,this.el.object3D.matrixNeedsUpdate=!0}else{let e=this.el.object3DMap.mesh;if(e){let a=e.geometry.boundingBox;t=(a.max.x-a.min.x)*e.scale.x,i=(a.max.y-a.min.y)*e.scale.y}else{let e=this.el.object3D.scale;t=e.x,i=e.y,e.x=1,e.y=1,e.z=1,this.el.object3D.matrixNeedsUpdate=!0}var a=this.el.parentEl.parentEl.object3D;t*=a.scale.x,i*=a.scale.y,a.scale.x=1,a.scale.y=1,a.scale.z=1,a.matrixNeedsUpdate=!0}if(t>0&&i>0){var o=Math.min(t*this.relativeSize,i*this.relativeSize);this.simpleContainer.setAttribute("scale",{x:o,y:o,z:o})}for(const e of this.el.object3D.children)e.visible=!1;this.el.appendChild(this.simpleContainer),this.isInteractive?(this.handleInteraction=new qe(this.el),this.simpleContainer.setAttribute("is-remote-hover-target",""),this.simpleContainer.setAttribute("tags",{singleActionButton:!0,inspectable:!0,isStatic:!0,togglesHoveredActionSet:!0}),this.simpleContainer.setAttribute("class","interactable"),this.clicked=this.clicked.bind(this),this.simpleContainer.object3D.addEventListener("interact",this.internalClicked),this.isDraggable&&(this.simpleContainer.setAttribute("tags",{singleActionButton:!0,isHoldable:!0,holdableButton:!0,inspectable:!0,isStatic:!0,togglesHoveredActionSet:!0}),this.dragStart=this.dragStart.bind(this),this.dragEnd=this.dragEnd.bind(this),this.simpleContainer.object3D.addEventListener("holdable-button-down",this.internalDragStart),this.simpleContainer.object3D.addEventListener("holdable-button-up",this.internalDragEnd)),this.hoverRayL=new THREE.Ray,this.hoverRayR=new THREE.Ray):(this.el.classList.contains("interactable")&&this.el.classList.remove("interactable"),this.el.removeAttribute("is-remote-hover-target")),this.el.hasAttribute("networked")&&this.el.removeAttribute("networked"),this.isNetworked&&(this.setupNetworkedEntity=function(t){var i,a,o=!0;t?(i=NAF.utils.getNetworkId(t)+"-"+e,o=a.components.networked.data.persistent):i=this.fullName.replaceAll("_","-")+"-"+e,NAF.entities.hasEntity(i)?a=NAF.entities.getEntity(i):((a=document.createElement("a-entity")).getSharedData=this.getSharedData,a.setAttribute("networked",{template:"#"+e+"-data-media",persistent:o,owner:"scene",networkId:i}),this.el.sceneEl.appendChild(a)),this.netEntity=a,NAF.utils.getNetworkedEntity(this.netEntity).then((t=>{this.stateSync=t.components[e+"-data"]}))},this.setupNetworkedEntity=this.setupNetworkedEntity.bind(this),this.setupNetworked=function(){NAF.utils.getNetworkedEntity(this.el).then((e=>{this.setupNetworkedEntity(e)})).catch((()=>{this.setupNetworkedEntity()}))},this.setupNetworked=this.setupNetworked.bind(this),NAF.connection&&NAF.connection.isConnected()?this.setupNetworked():this.el.sceneEl.addEventListener("didConnectToNetworkedScene",this.setupNetworked))}))};this.el.components["media-loader"]?this.el.addEventListener("media-loaded",(()=>{t()}),{once:!0}):t()}}}("test-cube"),Xe={schema:{name:{type:"string",default:""},isNetworked:{type:"boolean",default:!1},isInteractive:{type:"boolean",default:!0},isDraggable:{type:"boolean",default:!0},width:{type:"number",default:1},color:{type:"string",default:""},parameter1:{type:"string",default:""}},init:function(){this.startInit(),this.relativeSize=this.data.width,this.isDraggable=this.data.isDraggable,this.isInteractive=this.data.isInteractive,this.isNetworked=this.data.isNetworked,this.sharedData={color:new THREE.Color(this.data.color.length>0?this.data.color:"grey"),rotation:new THREE.Euler,position:new THREE.Vector3(0,.5,0)},this.initialEuler=new THREE.Euler,this.clickEvent=null,this.clickIntersection=null,this.data.name&&this.data.name.length>0&&(this.fullName=this.data.name),this.finishInit()},update:function(){},loadData:async function(){},initializeData:function(){this.box=new THREE.Mesh(new THREE.BoxGeometry(1,1,1,2,2,2),new THREE.MeshBasicMaterial({color:this.sharedData.color})),this.box.matrixAutoUpdate=!0,this.simpleContainer.setObject3D("box",this.box),this.box2=new THREE.Mesh(new THREE.BoxGeometry(.1,.1,.1,2,2,2),new THREE.MeshBasicMaterial({color:"black"})),this.box2.matrixAutoUpdate=!0,this.box2.position.copy(this.sharedData.position),this.box.add(this.box2),this.box2.el=this.simpleContainer,this.el.sceneEl.emit("updatePortals")},remove:function(){this.simpleContainer.removeObject3D("box"),this.box.geometry.dispose(),this.box.material.dispose(),this.box2.geometry.dispose(),this.box2.material.dispose(),this.removeTemplate()},clicked:function(e){if(this.clickIntersection=this.handleInteraction.getIntersection(e.object3D,[e.target]),this.clickEvent=e,this.clickIntersection)if(this.clickIntersection.object==this.box){let e=new THREE.Color(Math.random(),Math.random(),Math.random());this.box.material.color.set(e),this.sharedData.color.set(e),this.setSharedData()}else this.clickIntersection.object,this.box2;else console.warn("click didn't hit anything; shouldn't happen")},dragStart:function(e){this.handleInteraction.startDrag(e,this.clickIntersection.object)&&(this.clickIntersection.object==this.box?this.initialEuler.copy(this.box.rotation):this.clickIntersection.object==this.box2&&this.box2.material.color.set("red"))},dragEnd:function(e){this.handleInteraction.endDrag(e),this.clickIntersection.object==this.box||this.clickIntersection.object==this.box2&&this.box2.material.color.set("black")},setSharedEuler:function(e){Ye(this.sharedData.rotation,e,.05)||(this.sharedData.rotation.copy(e),this.setSharedData())},setSharedPosition:function(e){Ye(this.sharedData.position,e,.05)||(this.sharedData.position.copy(e),this.setSharedData())},setSharedData:function(){return!this.stateSync||this.stateSync.setSharedData(this.sharedData)},getSharedData:function(){return this.sharedData},tick:function(e){if(this.box){if(this.isInteractive)if(this.isDraggable&&this.handleInteraction.isDragging){if(this.clickIntersection.object==this.box)this.handleInteraction.drag(),this.box.rotation.set(this.initialEuler.x-this.handleInteraction.delta.x,this.initialEuler.y+this.handleInteraction.delta.y,this.initialEuler.z),this.setSharedEuler(this.box.rotation);else if(this.clickIntersection.object==this.box2){this.box2.visible=!1;let e=this.handleInteraction.getIntersection(this.handleInteraction.dragInteractor,[this.box]);if(this.box2.visible=!0,e){let t=this.box.worldToLocal(e.point);this.box2.position.copy(t),this.setSharedPosition(this.box2.position)}}}else{let e=this.handleInteraction.getInteractors(this.simpleContainer),t=!1;for(let i=0;i<e.length;i++){let a=this.handleInteraction.getIntersection(e[i],this.simpleContainer.object3D.children);a&&a.object===this.box2&&(this.box2.material.color.set("yellow"),t=!0)}t||this.box2.material.color.set("black")}if(this.isNetworked){if(!this.netEntity||!this.stateSync)return;if(this.stateSync.changed){this.stateSync.changed=!1;let e=this.stateSync.dataObject;this.sharedData.color.set(e.color),this.sharedData.rotation.copy(e.rotation),this.sharedData.position.copy(e.position),this.box.material.color.set(e.color),this.box.rotation.copy(e.rotation),this.box2.position.copy(e.position)}}}}};AFRAME.registerComponent("test-cube",{...Xe,...Ge}),function(e){AFRAME.registerComponent(e+"-data",{schema:{sampledata:{type:"string",default:"{}"}},init:function(){this.setSharedData=this.setSharedData.bind(this),this.dataObject=this.el.getSharedData();try{this.sharedData=encodeURIComponent(JSON.stringify(this.dataObject)),this.el.setAttribute(e+"-data","sampledata",this.sharedData)}catch(e){console.error("Couldn't encode initial data object: ",e,this.dataObject),this.sharedData="{}",this.dataObject={}}this.changed=!1},update(){if(this.changed=!(this.sharedData===this.data.sampledata),this.changed)try{this.dataObject=JSON.parse(decodeURIComponent(this.data.sampledata)),this.sharedData=this.data.sampledata,this.changed=!0}catch(e){console.error("couldn't parse JSON received in data-sync: ",e),this.sharedData="{}",this.dataObject={}}},play(){this.el.components.networked&&APP.utils&&APP.utils.applyPersistentSync(this.el.components.networked.data.networkId)},setSharedData(t){if(!NAF.utils.isMine(this.el)&&!NAF.utils.takeOwnership(this.el))return!1;try{var i=encodeURIComponent(JSON.stringify(t));return this.sharedData=i,this.dataObject=t,this.el.setAttribute(e+"-data","sampledata",i),!0}catch(e){return console.error("can't stringify the object passed to data-sync"),!1}}}),document.querySelector("a-assets").insertAdjacentHTML("beforeend",'\n<template id="'+e+'-data-media">\n  <a-entity\n    '+e+"-data\n  ></a-entity>\n</template>\n"),NAF.schemas.add({template:"#"+e+"-data-media",components:[{component:e+"-data",property:"sampledata"}],nonAuthorizedComponents:[{component:e+"-data",property:"sampledata"}]})}("test-cube");const $e=new THREE.Vector3;function Ze(){window.APP.scene.addEventListener("stateadded",(function(e){if("entered"===e.detail){var t=window.APP.scene.object3D.getObjectByName("lobbySphere");t&&(t.visible=!1)}}))}AFRAME.registerComponent("show-hide",{schema:{radius:{type:"number",default:1},showClose:{type:"boolean",default:!0}},init:function(){this.innerRadius=.95*this.data.radius,this.outerRadius=1.05*this.data.radius},tick:function(e){this.el.sceneEl.camera.getWorldPosition($e),this.el.object3D.worldToLocal($e);let t=$e.length();t<this.innerRadius?this.el.object3D.visible=this.data.showClose:t>this.outerRadius&&(this.el.object3D.visible=!this.data.showClose)}}),AFRAME.GLTFModelPlus.registerComponent("immersive-360","immersive-360"),AFRAME.GLTFModelPlus.registerComponent("portal","portal"),AFRAME.GLTFModelPlus.registerComponent("shader","shader"),AFRAME.GLTFModelPlus.registerComponent("parallax","parallax"),AFRAME.GLTFModelPlus.registerComponent("html-script","html-script"),AFRAME.GLTFModelPlus.registerComponent("region-hider","region-hider"),AFRAME.GLTFModelPlus.registerComponent("video-control-pad","video-control-pad"),AFRAME.GLTFModelPlus.registerComponent("show-hide","show-hide"),AFRAME.GLTFModelPlus.registerComponent("test-cube","test-cube"),AFRAME.GLTFModelPlus.registerComponent("test-cube","test-cube"),"complete"===document.readyState?Ze():document.addEventListener("DOMContentLoaded",Ze);
